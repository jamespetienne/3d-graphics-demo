import {
  AnimationMixer,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  CapsuleGeometry,
  ConeGeometry,
  CylinderGeometry,
  DoubleSide,
  Euler,
  ExtrudeGeometry,
  Float32BufferAttribute,
  Group,
  Line,
  Line3,
  LineBasicMaterial,
  LineSegments,
  LoopOnce,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  Object3D,
  Plane,
  PlaneGeometry,
  Points,
  PointsMaterial,
  Quaternion,
  REVISION,
  SphereGeometry,
  StaticDrawUsage,
  TorusGeometry,
  Triangle,
  Vector3
} from "./chunk-LFKGNFSN.js";
import {
  __commonJS,
  __toESM
} from "./chunk-WNKWOKNR.js";

// node_modules/@yandeu/events/cjs/version.js
var require_version = __commonJS({
  "node_modules/@yandeu/events/cjs/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "0.0.5";
  }
});

// node_modules/@yandeu/events/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@yandeu/events/cjs/index.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Events = void 0;
    var version_1 = require_version();
    var EE = (
      /** @class */
      function() {
        function EE2(fn, context, once) {
          if (once === void 0) {
            once = false;
          }
          this.fn = fn;
          this.context = context;
          this.once = once;
        }
        return EE2;
      }()
    );
    var addListener = function(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once);
      if (!emitter._events.has(event))
        emitter._events.set(event, listener), emitter._eventsCount++;
      else if (!emitter._events.get(event).fn)
        emitter._events.get(event).push(listener);
      else
        emitter._events.set(event, [emitter._events.get(event), listener]);
      return emitter;
    };
    var clearEvent = function(emitter, event) {
      if (--emitter._eventsCount === 0)
        emitter._events = /* @__PURE__ */ new Map();
      else
        emitter._events.delete(event);
    };
    var Events4 = (
      /** @class */
      function() {
        function Events5() {
          this._events = /* @__PURE__ */ new Map();
          this._eventsCount = 0;
        }
        Object.defineProperty(Events5, "VERSION", {
          get: function() {
            return version_1.VERSION;
          },
          enumerable: false,
          configurable: true
        });
        Events5.prototype.eventNames = function() {
          return Array.from(this._events.keys());
        };
        Events5.prototype.listeners = function(event) {
          var handlers = this._events.get(event);
          if (!handlers)
            return [];
          if (handlers.fn)
            return [handlers.fn];
          for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
            ee[i] = handlers[i].fn;
          }
          return ee;
        };
        Events5.prototype.listenerCount = function(event) {
          var listeners = this._events.get(event);
          if (!listeners)
            return 0;
          if (listeners.fn)
            return 1;
          return listeners.length;
        };
        Events5.prototype.emit = function(event) {
          var _a, _b;
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          if (!this._events.has(event))
            return false;
          var listeners = this._events.get(event);
          var i;
          if (listeners.fn) {
            if (listeners.once)
              this.removeListener(event, listeners.fn, void 0, true);
            return (_a = listeners.fn).call.apply(_a, __spreadArray([listeners.context], args)), true;
          } else {
            var length_1 = listeners.length;
            for (i = 0; i < length_1; i++) {
              if (listeners[i].once)
                this.removeListener(event, listeners[i].fn, void 0, true);
              (_b = listeners[i].fn).call.apply(_b, __spreadArray([listeners[i].context], args));
            }
          }
          return true;
        };
        Events5.prototype.on = function(event, fn, context) {
          return addListener(this, event, fn, context, false);
        };
        Events5.prototype.once = function(event, fn, context) {
          return addListener(this, event, fn, context, true);
        };
        Events5.prototype.removeListener = function(event, fn, context, once) {
          if (!this._events.has(event))
            return this;
          if (!fn) {
            clearEvent(this, event);
            return this;
          }
          var listeners = this._events.get(event);
          if (listeners.fn) {
            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
              clearEvent(this, event);
            }
          } else {
            for (var i = 0, events = [], length = listeners.length; i < length; i++) {
              if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                events.push(listeners[i]);
              }
            }
            if (events.length)
              this._events.set(event, events.length === 1 ? events[0] : events);
            else
              clearEvent(this, event);
          }
          return this;
        };
        Events5.prototype.removeAllListeners = function(event) {
          if (event) {
            if (this._events.delete(event))
              clearEvent(this, event);
          } else {
            this._events = /* @__PURE__ */ new Map();
            this._eventsCount = 0;
          }
          return this;
        };
        Object.defineProperty(Events5.prototype, "off", {
          // alias
          get: function() {
            return this.removeListener;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Events5.prototype, "addListener", {
          // alias
          get: function() {
            return this.on;
          },
          enumerable: false,
          configurable: true
        });
        return Events5;
      }()
    );
    exports.Events = Events4;
  }
});

// node_modules/@enable3d/common/dist/logger.js
var loggerCache = /* @__PURE__ */ new Map();
var LOG_LIMIT = 5;
var logger = (msg, error = false) => {
  if (!loggerCache.has(msg)) {
    loggerCache.set(msg, 1);
  } else {
    const count = loggerCache.get(msg);
    if (typeof count === "undefined")
      return;
    if (count >= LOG_LIMIT)
      return;
    loggerCache.set(msg, count + 1);
  }
  if (error)
    console.error(`%c [enable3d] ${msg} `, "background: #222; color: #bada55");
  else
    console.warn(`%c [enable3d] ${msg} `, "background: #222; color: #bada55");
};

// node_modules/@enable3d/common/dist/physicsBody.js
var import_events = __toESM(require_cjs());
var PhysicsBody = class {
  constructor(physics, ammo) {
    this.physics = physics;
    this.ammo = ammo;
    this.ignoreScale = false;
    this.isSoftBody = false;
    this.offset = { x: 0, y: 0, z: 0 };
    this.errors = [];
    this.checkCollisions = false;
    this.impact = [];
    this.breakable = false;
    this.fractureImpulse = 1;
    this.didUpdate = false;
    this.skipUpdate = false;
    this._emitUpdateEvents = false;
    this._needUpdate = false;
    this.tmpEuler = new Euler();
    this.tmpQuaternion = new Quaternion();
    this.tmpBtVector3 = new Ammo.btVector3();
    this.tmpBtVector3_1 = new Ammo.btVector3();
    this.tmpBtQuaternion = new Ammo.btQuaternion(0, 0, 0, 1);
    this.eventEmitter = new import_events.Events();
    this.name = ammo.name;
  }
  /**
   * Don't call this manually! Do physics.destroy() instead.
   */
  destructor() {
    if (this.eventEmitter)
      this.eventEmitter.removeAllListeners();
    Ammo.destroy(this.tmpBtVector3);
    Ammo.destroy(this.tmpBtVector3_1);
    Ammo.destroy(this.tmpBtQuaternion);
    Ammo.destroy(this.ammo.getCollisionShape());
    Ammo.destroy(this.ammo);
  }
  setupEventEmitter() {
    if (typeof this.eventEmitter === "undefined")
      this.eventEmitter = new import_events.Events();
  }
  get needUpdate() {
    return this._needUpdate;
  }
  set needUpdate(need) {
    if (!need && this._needUpdate)
      this.didUpdate = true;
    this._needUpdate = need;
  }
  onUpdateEvent(updateCallback, once = false) {
    this.setupEventEmitter();
    this._emitUpdateEvents = true;
    if (once)
      this.eventEmitter.once("update", () => {
        updateCallback();
      });
    else
      this.eventEmitter.on("update", () => {
        updateCallback();
      });
  }
  get on() {
    return {
      update: (updateCallback) => this.onUpdateEvent(updateCallback),
      collision: (collisionCallback) => this.onCollision(collisionCallback)
    };
  }
  get once() {
    return {
      update: (updateCallback) => this.onUpdateEvent(updateCallback, true)
    };
  }
  onCollision(collisionCallback) {
    this.checkCollisions = true;
    this.physics.collisionEvents.on("collision", (data) => {
      const { bodies, event } = data;
      if (bodies[0].name === this.name)
        collisionCallback(bodies[1], event);
      else if (bodies[1].name === this.name)
        collisionCallback(bodies[0], event);
    });
  }
  /** You have to call transform() before you can get or set the body's position or rotation. (for headless mode only) */
  transform() {
    const t = this.physics.worldTransform;
    this.ammo.getMotionState().getWorldTransform(t);
  }
  /** You have to call refresh() after you set the position or rotation of the body. (for headless mode only) */
  refresh() {
    const t = this.physics.worldTransform;
    this.ammo.getMotionState().setWorldTransform(t);
  }
  /** Set the rotation in radians. (for headless mode only) */
  setRotation(x, y, z) {
    const e = this.tmpEuler.set(x, y, z);
    const q = this.tmpQuaternion.set(0, 0, 0, 1);
    q.setFromEuler(e);
    this.tmpBtQuaternion.setValue(0, 0, 0, 1);
    const ammoQuat = this.tmpBtQuaternion;
    ammoQuat.setValue(q.x, q.y, q.z, q.w);
    const t = this.physics.worldTransform;
    t.setRotation(ammoQuat);
  }
  /** Get the rotation in radians. (for headless mode only) */
  get rotation() {
    let x, y, z;
    const t = this.physics.worldTransform;
    const ammoQuat = t.getRotation();
    let q1 = this.tmpQuaternion.set(ammoQuat.x(), ammoQuat.y(), ammoQuat.z(), ammoQuat.w());
    if (q1.w > 1)
      q1 = q1.normalize();
    const angle = 2 * Math.acos(q1.w);
    const s = Math.sqrt(1 - q1.w * q1.w);
    if (s < 1e-3) {
      x = q1.x;
      y = q1.y;
      z = q1.z;
    } else {
      x = q1.x / s;
      y = q1.y / s;
      z = q1.z / s;
    }
    return { x: x * angle, y: y * angle, z: z * angle };
  }
  /** Get the quaternion. (for headless mode only) */
  get quaternion() {
    const t = this.physics.worldTransform;
    const q = t.getRotation();
    return { x: q.x(), y: q.y(), z: q.z(), w: q.w() };
  }
  /** Set position. (for headless mode only) */
  setPosition(x, y, z) {
    const t = this.physics.worldTransform;
    t.getOrigin().setValue(x, y, z);
  }
  /** Get position. (for headless mode only) */
  get position() {
    const t = this.physics.worldTransform;
    return { x: t.getOrigin().x(), y: t.getOrigin().y(), z: t.getOrigin().z() };
  }
  get velocity() {
    return {
      x: this.ammo.getLinearVelocity().x(),
      y: this.ammo.getLinearVelocity().y(),
      z: this.ammo.getLinearVelocity().z()
    };
  }
  get angularVelocity() {
    return {
      x: this.ammo.getAngularVelocity().x(),
      y: this.ammo.getAngularVelocity().y(),
      z: this.ammo.getAngularVelocity().z()
    };
  }
  setVelocity(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.setLinearVelocity(this.tmpBtVector3);
  }
  setVelocityX(value) {
    this.tmpBtVector3.setValue(value, this.velocity.y, this.velocity.z);
    this.ammo.setLinearVelocity(this.tmpBtVector3);
  }
  setVelocityY(value) {
    this.tmpBtVector3.setValue(this.velocity.x, value, this.velocity.z);
    this.ammo.setLinearVelocity(this.tmpBtVector3);
  }
  setVelocityZ(value) {
    this.tmpBtVector3.setValue(this.velocity.x, this.velocity.y, value);
    this.ammo.setLinearVelocity(this.tmpBtVector3);
  }
  setAngularVelocity(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.setAngularVelocity(this.tmpBtVector3);
  }
  setAngularVelocityX(value) {
    this.tmpBtVector3.setValue(value, this.angularVelocity.y, this.angularVelocity.z);
    this.ammo.setAngularVelocity(this.tmpBtVector3);
  }
  setAngularVelocityY(value) {
    this.tmpBtVector3.setValue(this.angularVelocity.x, value, this.angularVelocity.z);
    this.ammo.setAngularVelocity(this.tmpBtVector3);
  }
  setAngularVelocityZ(value) {
    this.tmpBtVector3.setValue(this.angularVelocity.x, this.angularVelocity.y, value);
    this.ammo.setAngularVelocity(this.tmpBtVector3);
  }
  // Apply Force methods
  applyForce(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.applyCentralImpulse(this.tmpBtVector3);
  }
  applyForceX(value) {
    this.tmpBtVector3.setValue(value, 0, 0);
    this.ammo.applyCentralImpulse(this.tmpBtVector3);
  }
  applyForceY(value) {
    this.tmpBtVector3.setValue(0, value, 0);
    this.ammo.applyCentralImpulse(this.tmpBtVector3);
  }
  applyForceZ(value) {
    this.tmpBtVector3.setValue(0, 0, value);
    this.ammo.applyCentralImpulse(this.tmpBtVector3);
  }
  // Apply "Something" Methods
  applyCentralForce(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.applyCentralForce(this.tmpBtVector3);
  }
  applyCentralImpulse(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.applyCentralImpulse(this.tmpBtVector3);
  }
  applyCentralLocalForce(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.applyCentralLocalForce(this.tmpBtVector3);
  }
  applyImpulse(impulse, relativePosition) {
    this.tmpBtVector3.setValue(impulse.x || 0, impulse.y || 0, impulse.z || 0);
    this.tmpBtVector3_1.setValue(relativePosition.x || 0, relativePosition.y || 0, relativePosition.z || 0);
    this.ammo.applyImpulse(this.tmpBtVector3, this.tmpBtVector3_1);
  }
  applyLocalTorque(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.applyLocalTorque(this.tmpBtVector3);
  }
  applyTorque(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.applyTorque(this.tmpBtVector3);
  }
  applyTorqueImpulse(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.applyTorqueImpulse(this.tmpBtVector3);
  }
  /**
   * Add the collision flags
   * @param value 0 is DYNAMIC, 1 is STATIC, 2 is KINEMATIC, 4 GHOST
   */
  // https://github.com/bulletphysics/bullet3/blob/aae8048722f2596f7e2bdd52d2a1dcb52a218f2b/src/BulletCollision/CollisionDispatch/btCollisionObject.h#L128
  setCollisionFlags(value) {
    this.ammo.setCollisionFlags(value);
  }
  /**
   * Get the collision flags
   * @param value 0 is DYNAMIC, 1 is STATIC, 2 is KINEMATIC, 4 GHOST
   */
  getCollisionFlags() {
    return this.ammo.getCollisionFlags();
  }
  /**
   * Set the restitution (same as bounciness)
   * @param value A number from 0 to 1.
   */
  setRestitution(value) {
    this.ammo.setRestitution(value);
  }
  /**
   * Set the bounciness (same as restitution)
   * @param value A number from 0 to 1.
   */
  setBounciness(value) {
    this.setRestitution(value);
  }
  /**
   * Set the friction
   * @param value A number from 0 to 1.
   */
  setFriction(value) {
    this.ammo.setFriction(value);
  }
  /**
   * Set the linear and angular damping
   * @param linear A number from 0 to 1.
   * @param angular A number from 0 to 1.
   */
  setDamping(linear, angular) {
    this.ammo.setDamping(linear, angular);
  }
  /** Set per body gravity */
  setGravity(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.setGravity(this.tmpBtVector3);
  }
  setLinearFactor(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.setLinearFactor(this.tmpBtVector3);
  }
  setAngularFactor(x, y, z) {
    this.tmpBtVector3.setValue(x, y, z);
    this.ammo.setAngularFactor(this.tmpBtVector3);
  }
  setCcdMotionThreshold(threshold) {
    this.ammo.setCcdMotionThreshold(threshold);
  }
  setCcdSweptSphereRadius(radius) {
    this.ammo.setCcdSweptSphereRadius(radius);
  }
};
var physicsBody_default = PhysicsBody;

// node_modules/@enable3d/common/dist/extendedObject3D.js
var ExtendedObject3D = class extends Object3D {
  constructor() {
    super();
    this.isExtendedObject3D = true;
    this.isGroup = false;
    this.vector3 = new Vector3();
    this.hasBody = false;
    this.fragmentDepth = 0;
    this.breakable = false;
    this.fractureImpulse = 1;
    this._currentAnimation = "";
    this._animationActions = /* @__PURE__ */ new Map();
    this.name = `object-${this.id}`;
  }
  /** Returns all values relative to the world. */
  get world() {
    return {
      theta: this.worldTheta,
      phi: this.worldPhi
    };
  }
  /** Get the theta relative to the world. */
  get worldTheta() {
    this.getWorldDirection(this.vector3);
    return Math.atan2(this.vector3.x, this.vector3.z);
  }
  /** Get the phi relative to the world. */
  get worldPhi() {
    this.getWorldDirection(this.vector3);
    return Math.acos(this.vector3.y);
  }
  set animationMixer(animationMixer) {
    this._animationMixer = animationMixer;
  }
  get animationMixer() {
    if (!this._animationMixer)
      this._animationMixer = new AnimationMixer(this);
    return this._animationMixer;
  }
  /** Control your animations. */
  get anims() {
    return {
      /** Get the name of the current animation. */
      current: this._currentAnimation,
      /** Add animation name and the AnimationClip. */
      add: (name, animation) => this._animsAdd(name, animation),
      /** Get AnimationAction by animation name. */
      get: (name) => this._animsGet(name),
      /**
       * Play an animation.
       * @param name Animation name.
       * @param transitionDuration Transition duration in ms.
       * @param loop Should the animation loop?
       */
      play: (name, transitionDuration = 500, loop = true) => this._animsPlay(name, transitionDuration, loop),
      /** Get the AnimationMixer */
      mixer: this.animationMixer
    };
  }
  /** @deprecated Please use anims instead! */
  get animation() {
    logger('Please use "anims" instead of "animation"');
    return this.anims;
  }
  _animsAdd(name, animation) {
    this._animationActions.set(name, this.animationMixer.clipAction(animation));
  }
  _animsGet(name) {
    const action = this._animationActions.get(name);
    if (!action)
      logger(`Animation(${name}) not found!`);
    return action;
  }
  _animsPlay(name, transitionDuration = 500, loop = true) {
    const next = this._animationActions.get(name);
    const current = this._animationActions.get(this._currentAnimation);
    if (next) {
      next.reset();
      if (current) {
        next.crossFadeFrom(current, transitionDuration / 1e3, true);
        next.clampWhenFinished = true;
      }
      if (!loop)
        next.setLoop(LoopOnce, 0);
      next.play();
    }
    this._currentAnimation = name;
  }
  /** @deprecated Use animation.play(name) instead! */
  setAction(name) {
    logger(`setAction(${name}) is deprecated. Use animation.play(${name}) instead!`);
  }
  traverse(callback) {
    super.traverse(callback);
  }
  traverseVisible(callback) {
    super.traverseVisible(callback);
  }
  traverseAncestors(callback) {
    super.traverseAncestors(callback);
  }
};

// node_modules/@enable3d/common/dist/extendedMesh.js
var ExtendedMesh = class extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.isExtendedMesh = true;
    this.isGroup = false;
    this.vector3 = new Vector3();
    this.hasBody = false;
    this.fragmentDepth = 0;
    this.breakable = false;
    this.fractureImpulse = 1;
    this.name = `object-${this.id}`;
  }
  /** Returns all values relative to the world. */
  get world() {
    return {
      theta: this.worldTheta,
      phi: this.worldPhi
    };
  }
  /** Get the theta relative to the world. */
  get worldTheta() {
    this.getWorldDirection(this.vector3);
    return Math.atan2(this.vector3.x, this.vector3.z);
  }
  /** Get the phi relative to the world. */
  get worldPhi() {
    this.getWorldDirection(this.vector3);
    return Math.acos(this.vector3.y);
  }
};

// node_modules/@enable3d/common/dist/extendedGroup.js
var ExtendedGroup = class extends Group {
  constructor() {
    super();
    this.isExtendedGroup = true;
    this.isMesh = false;
    this.hasBody = false;
    this.fragmentDepth = 0;
    this.breakable = false;
    this.fractureImpulse = 1;
    this.name = `object-${this.id}`;
  }
};

// node_modules/@enable3d/ammo-physics/dist/shapes.js
var Shapes = class {
  constructor(factory, addExisting) {
    this.factory = factory;
    this.addExisting = addExisting;
  }
  addPlane(planeConfig = {}, materialConfig = {}) {
    const plane = this.factory.add.plane(planeConfig, materialConfig);
    this.addExisting(plane, planeConfig);
    return plane;
  }
  addSphere(sphereConfig = {}, materialConfig = {}) {
    const sphere = this.factory.add.sphere(sphereConfig, materialConfig);
    this.addExisting(sphere, sphereConfig);
    return sphere;
  }
  addBox(boxConfig = {}, materialConfig = {}) {
    const box = this.factory.add.box(boxConfig, materialConfig);
    this.addExisting(box, boxConfig);
    return box;
  }
  addGround(groundConfig, materialConfig = {}) {
    const ground = this.factory.add.ground(groundConfig, materialConfig);
    const config = { ...groundConfig, mass: 0, collisionFlags: 1 };
    this.addExisting(ground, config);
    return ground;
  }
  addCapsule(capsuleConfig = {}, materialConfig = {}) {
    const capsule = this.factory.add.capsule(capsuleConfig, materialConfig);
    this.addExisting(capsule, capsuleConfig);
    return capsule;
  }
  addCylinder(cylinderConfig = {}, materialConfig = {}) {
    const cylinder = this.factory.add.cylinder(cylinderConfig, materialConfig);
    this.addExisting(cylinder, cylinderConfig);
    return cylinder;
  }
  addCone(coneConfig = {}, materialConfig = {}) {
    const cone = this.factory.add.cone(coneConfig, materialConfig);
    this.addExisting(cone, coneConfig);
    return cone;
  }
  addTorus(torusConfig = {}, materialConfig = {}) {
    const torus = this.factory.add.torus(torusConfig, materialConfig);
    this.addExisting(torus, torusConfig);
    return torus;
  }
  addExtrude(extrudeConfig, materialConfig = {}) {
    const object = this.factory.add.extrude(extrudeConfig, materialConfig);
    object.translateX(1);
    this.addExisting(object);
    return object;
  }
};
var shapes_default = Shapes;

// node_modules/@enable3d/ammo-physics/dist/constraints.js
var Constraints = class {
  constructor(worldTransform, physicsWorld) {
    this.worldTransform = worldTransform;
    this.physicsWorld = physicsWorld;
    this.tmpBtVector3 = new Ammo.btVector3();
  }
  toAmmoV3(v, d = 0) {
    return new Ammo.btVector3(typeof (v == null ? void 0 : v.x) !== "undefined" ? v.x : d, typeof (v == null ? void 0 : v.y) !== "undefined" ? v.y : d, typeof (v == null ? void 0 : v.z) !== "undefined" ? v.z : d);
  }
  get addConstraints() {
    return {
      lock: (bodyA, bodyB, disableCollisionsBetweenLinkedBodies) => this.lock(bodyA, bodyB, disableCollisionsBetweenLinkedBodies),
      fixed: (bodyA, bodyB, disableCollisionsBetweenLinkedBodies) => this.fixed(bodyA, bodyB, disableCollisionsBetweenLinkedBodies),
      pointToPoint: (bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies) => this.pointToPoint(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies),
      hinge: (bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies) => this.hinge(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies),
      slider: (bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies) => this.slider(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies),
      spring: (bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies) => this.spring(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies),
      coneTwist: (bodyA, bodyB, config = { frameA: {}, frameB: {} }, disableCollisionsBetweenLinkedBodies) => this.coneTwist(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies),
      dof: (bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies) => this.dof(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies)
    };
  }
  getTransform(bodyA, bodyB, offset = { x: 0, y: 0, z: 0 }, center = false) {
    offset = { x: 0, y: 0, z: 0, ...offset };
    const centerVector = (v1, v2) => {
      var dx = (v1.x() - v2.x()) / 2 + offset.x;
      var dy = (v1.y() - v2.y()) / 2 + offset.y;
      var dz = (v1.z() - v2.z()) / 2 + offset.z;
      return new Ammo.btVector3(dx, dy, dz);
    };
    const transformB = new Ammo.btTransform();
    transformB.setIdentity();
    if (!center) {
      transformB.setOrigin(new Ammo.btVector3(offset.x, offset.y, offset.z));
      const transformA = bodyA.getCenterOfMassTransform().inverse().op_mul(bodyB.getWorldTransform()).op_mul(transformB);
      return { transformA, transformB };
    } else {
      const center2 = centerVector(bodyA.getWorldTransform().getOrigin(), bodyB.getWorldTransform().getOrigin());
      const transformB2 = new Ammo.btTransform();
      transformB2.setIdentity();
      transformB2.setOrigin(center2);
      const transformA = bodyA.getCenterOfMassTransform().inverse().op_mul(bodyB.getWorldTransform());
      transformA.op_mul(transformB2);
      return { transformA, transformB: transformB2 };
    }
  }
  lock(bodyA, bodyB, disableCollisionsBetweenLinkedBodies = true) {
    const zero = { x: 0, y: 0, z: 0 };
    return this.dof(bodyA, bodyB, { angularLowerLimit: zero, angularUpperLimit: zero }, disableCollisionsBetweenLinkedBodies);
  }
  fixed(bodyA, bodyB, disableCollisionsBetweenLinkedBodies = true) {
    const transform = this.getTransform(bodyA.ammo, bodyB.ammo);
    transform.transformA.setRotation(bodyA.ammo.getWorldTransform().getRotation());
    transform.transformB.setRotation(bodyB.ammo.getWorldTransform().getRotation());
    const constraint = new Ammo.btFixedConstraint(bodyA.ammo, bodyB.ammo, transform.transformA, transform.transformB);
    this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
    return constraint;
  }
  pointToPoint(bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies = true) {
    const { pivotA, pivotB } = config;
    const pivotV3 = new Ammo.btVector3((pivotA == null ? void 0 : pivotA.x) || 0, (pivotA == null ? void 0 : pivotA.y) || 0, (pivotA == null ? void 0 : pivotA.z) || 0);
    const targetPivotV3 = new Ammo.btVector3((pivotB == null ? void 0 : pivotB.x) || 0, (pivotB == null ? void 0 : pivotB.y) || 0, (pivotB == null ? void 0 : pivotB.z) || 0);
    const constraint = new Ammo.btPoint2PointConstraint(bodyA.ammo, bodyB.ammo, pivotV3, targetPivotV3);
    this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
    return constraint;
  }
  hinge(bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies = true) {
    const { pivotA, pivotB, axisA, axisB } = config;
    const pivotV3 = new Ammo.btVector3((pivotA == null ? void 0 : pivotA.x) || 0, (pivotA == null ? void 0 : pivotA.y) || 0, (pivotA == null ? void 0 : pivotA.z) || 0);
    const targetPivotV3 = new Ammo.btVector3((pivotB == null ? void 0 : pivotB.x) || 0, (pivotB == null ? void 0 : pivotB.y) || 0, (pivotB == null ? void 0 : pivotB.z) || 0);
    const axisV3 = new Ammo.btVector3((axisA == null ? void 0 : axisA.x) || 0, (axisA == null ? void 0 : axisA.y) || 0, (axisA == null ? void 0 : axisA.z) || 0);
    const targetAxisV3 = new Ammo.btVector3((axisB == null ? void 0 : axisB.x) || 0, (axisB == null ? void 0 : axisB.y) || 0, (axisB == null ? void 0 : axisB.z) || 0);
    const constraint = new Ammo.btHingeConstraint(bodyA.ammo, bodyB.ammo, pivotV3, targetPivotV3, axisV3, targetAxisV3, true);
    this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
    return constraint;
  }
  // https://pybullet.org/Bullet/phpBB3/viewtopic.php?f=9&t=12690&p=42152&hilit=btSliderConstraint#p42152
  slider(bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies = true) {
    const transform = this.getTransform(bodyA.ammo, bodyB.ammo);
    const { frameA = {}, frameB = {}, linearLowerLimit: lll = 0, linearUpperLimit: lul = 0, angularLowerLimit: all = 0, angularUpperLimit: aul = 0 } = config;
    const rotationA = transform.transformA.getRotation();
    rotationA.setEulerZYX(frameA.x || 0, frameA.y || 0, frameA.z || 0);
    transform.transformA.setRotation(rotationA);
    const rotationB = transform.transformB.getRotation();
    rotationB.setEulerZYX(frameB.x || 0, frameB.y || 0, frameB.z || 0);
    transform.transformB.setRotation(rotationB);
    const constraint = new Ammo.btSliderConstraint(bodyA.ammo, bodyB.ammo, transform.transformA, transform.transformB, true);
    constraint.setLowerLinLimit(lll);
    constraint.setUpperLinLimit(lul);
    constraint.setLowerAngLimit(all);
    constraint.setUpperAngLimit(aul);
    this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
    return constraint;
  }
  spring(bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies = true) {
    const { stiffness = 50, damping = 0.01, angularLock = false, linearLowerLimit: lll = {}, linearUpperLimit: lul = {}, angularLowerLimit: all = {}, angularUpperLimit: aul = {}, offset = {}, center = false, enableSpring = true } = config;
    const off = { x: 0, y: 0, z: 0, ...offset };
    const transform = this.getTransform(bodyA.ammo, bodyB.ammo, off, center);
    const constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA.ammo, bodyB.ammo, transform.transformA, transform.transformB, true);
    this.tmpBtVector3.setValue(lll.x || 0, lll.y || 0, lll.z || 0);
    constraint.setLinearLowerLimit(this.tmpBtVector3);
    this.tmpBtVector3.setValue(lul.x || 0, lul.y || 0, lul.z || 0);
    constraint.setLinearUpperLimit(this.tmpBtVector3);
    if (angularLock) {
      this.tmpBtVector3.setValue(0, 0, 0);
      constraint.setAngularLowerLimit(this.tmpBtVector3);
      constraint.setAngularUpperLimit(this.tmpBtVector3);
    } else {
      console.log(all, aul);
      constraint.setAngularLowerLimit(this.toAmmoV3(all, -Math.PI));
      constraint.setAngularUpperLimit(this.toAmmoV3(aul, Math.PI));
    }
    for (let i = 0; i < 3; i++) {
      constraint.enableSpring(i, enableSpring);
      constraint.setStiffness(i, stiffness);
      constraint.setDamping(i, damping);
    }
    this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
    return constraint;
  }
  coneTwist(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies = true) {
    const { frameA, frameB } = config;
    const rbAFrame = new Ammo.btTransform();
    rbAFrame.setIdentity();
    rbAFrame.getOrigin().setValue((frameA == null ? void 0 : frameA.x) || 0, (frameA == null ? void 0 : frameA.y) || 0, (frameA == null ? void 0 : frameA.z) || 0);
    const rbBFrame = new Ammo.btTransform();
    rbBFrame.setIdentity();
    rbBFrame.getOrigin().setValue((frameB == null ? void 0 : frameB.x) || 0, (frameB == null ? void 0 : frameB.y) || 0, (frameB == null ? void 0 : frameB.z) || 0);
    const t = this.getTransform(bodyA.ammo, bodyB.ammo);
    const constraint = new Ammo.btConeTwistConstraint(bodyB.ammo, bodyA.ammo, rbAFrame, rbBFrame);
    constraint.setAngularOnly(true);
    this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
    return constraint;
  }
  dof(bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies = true) {
    const { offset, center = false } = config;
    const off = { x: 0, y: 0, z: 0, ...offset };
    const transform = this.getTransform(bodyA.ammo, bodyB.ammo, off, center);
    const constraint = new Ammo.btGeneric6DofConstraint(bodyA.ammo, bodyB.ammo, transform.transformA, transform.transformB, true);
    const { linearLowerLimit, linearUpperLimit, angularLowerLimit, angularUpperLimit } = config;
    const lll = this.toAmmoV3(linearLowerLimit);
    const lul = this.toAmmoV3(linearUpperLimit);
    const all = this.toAmmoV3(angularLowerLimit, -Math.PI);
    const aul = this.toAmmoV3(angularUpperLimit, Math.PI);
    constraint.setLinearLowerLimit(lll);
    constraint.setLinearUpperLimit(lul);
    constraint.setAngularLowerLimit(all);
    constraint.setAngularUpperLimit(aul);
    Ammo.destroy(lll);
    Ammo.destroy(lul);
    Ammo.destroy(all);
    Ammo.destroy(aul);
    this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
    return constraint;
  }
};

// node_modules/@enable3d/ammo-physics/dist/physics.js
var import_events3 = __toESM(require_cjs());

// node_modules/@enable3d/ammo-physics/dist/three-to-ammo.js
var TYPE = {
  BOX: "box",
  CYLINDER: "cylinder",
  SPHERE: "sphere",
  CAPSULE: "capsule",
  CONE: "cone",
  HULL: "hull",
  HACD: "hacd",
  VHACD: "vhacd",
  MESH: "mesh",
  HEIGHTFIELD: "heightfield"
};
var FIT = {
  ALL: "all",
  MANUAL: "manual"
  //A single shape is sized manually. Requires halfExtents or sphereRadius.
};
var createHullShape = function() {
  const vertex = new Vector3();
  const center = new Vector3();
  const matrix = new Matrix4();
  return function(vertices, matrices, matrixWorld, options = {}) {
    options.type = TYPE.HULL;
    _setOptions(options);
    if (options.fit === FIT.MANUAL) {
      console.warn("cannot use fit: manual with type: hull");
      return null;
    }
    const bounds = _computeBounds(vertices, matrices);
    const btVertex = new Ammo.btVector3();
    const originalHull = new Ammo.btConvexHullShape();
    originalHull.setMargin(options.margin);
    center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);
    let vertexCount = 0;
    for (let i = 0; i < vertices.length; i++) {
      vertexCount += vertices[i].length / 3;
    }
    const maxVertices = options.hullMaxVertices || 1e5;
    if (vertexCount > maxVertices) {
      console.warn(`too many vertices for hull shape; sampling ~${maxVertices} from ~${vertexCount} vertices`);
    }
    const p = Math.min(1, maxVertices / vertexCount);
    for (let i = 0; i < vertices.length; i++) {
      const components = vertices[i];
      matrix.fromArray(matrices[i]);
      for (let j = 0; j < components.length; j += 3) {
        const isLastVertex = i === vertices.length - 1 && j === components.length - 3;
        if (Math.random() <= p || isLastVertex) {
          vertex.set(components[j], components[j + 1], components[j + 2]).applyMatrix4(matrix).sub(center);
          btVertex.setValue(vertex.x, vertex.y, vertex.z);
          originalHull.addPoint(btVertex, isLastVertex);
        }
      }
    }
    let collisionShape = originalHull;
    if (originalHull.getNumVertices() >= 100) {
      const shapeHull = new Ammo.btShapeHull(originalHull);
      shapeHull.buildHull(options.margin);
      Ammo.destroy(originalHull);
      collisionShape = new Ammo.btConvexHullShape(Ammo.getPointer(shapeHull.getVertexPointer()), shapeHull.numVertices());
      Ammo.destroy(shapeHull);
    }
    Ammo.destroy(btVertex);
    _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));
    return collisionShape;
  };
}();
var createHACDShapes = function() {
  const vector = new Vector3();
  const center = new Vector3();
  const matrix = new Matrix4();
  return function(vertices, matrices, indexes, matrixWorld, options = {}) {
    options.type = TYPE.HACD;
    _setOptions(options);
    if (options.fit === FIT.MANUAL) {
      console.warn("cannot use fit: manual with type: hacd");
      return [];
    }
    if (!Ammo.hasOwnProperty("HACD")) {
      console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version.");
      return [];
    }
    const bounds = _computeBounds(vertices, matrices);
    const scale = _computeScale(matrixWorld, options);
    let vertexCount = 0;
    let triCount = 0;
    center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);
    for (let i = 0; i < vertices.length; i++) {
      vertexCount += vertices[i].length / 3;
      if (indexes && indexes[i]) {
        triCount += indexes[i].length / 3;
      } else {
        triCount += vertices[i].length / 9;
      }
    }
    const hacd = new Ammo.HACD();
    if (options.hasOwnProperty("compacityWeight"))
      hacd.SetCompacityWeight(options.compacityWeight);
    if (options.hasOwnProperty("volumeWeight"))
      hacd.SetVolumeWeight(options.volumeWeight);
    if (options.hasOwnProperty("nClusters"))
      hacd.SetNClusters(options.nClusters);
    if (options.hasOwnProperty("nVerticesPerCH"))
      hacd.SetNVerticesPerCH(options.nVerticesPerCH);
    if (options.hasOwnProperty("concavity"))
      hacd.SetConcavity(options.concavity);
    const points = Ammo._malloc(vertexCount * 3 * 8);
    const triangles = Ammo._malloc(triCount * 3 * 4);
    hacd.SetPoints(points);
    hacd.SetTriangles(triangles);
    hacd.SetNPoints(vertexCount);
    hacd.SetNTriangles(triCount);
    let pptr = points / 8, tptr = triangles / 4;
    for (let i = 0; i < vertices.length; i++) {
      const components = vertices[i];
      matrix.fromArray(matrices[i]);
      for (let j = 0; j < components.length; j += 3) {
        vector.set(components[j + 0], components[j + 1], components[j + 2]).applyMatrix4(matrix).sub(center);
        Ammo.HEAPF64[pptr + 0] = vector.x;
        Ammo.HEAPF64[pptr + 1] = vector.y;
        Ammo.HEAPF64[pptr + 2] = vector.z;
        pptr += 3;
      }
      if (indexes[i]) {
        const indices = indexes[i];
        for (let j = 0; j < indices.length; j++) {
          Ammo.HEAP32[tptr] = indices[j];
          tptr++;
        }
      } else {
        for (let j = 0; j < components.length / 3; j++) {
          Ammo.HEAP32[tptr] = j;
          tptr++;
        }
      }
    }
    hacd.Compute();
    Ammo._free(points);
    Ammo._free(triangles);
    const nClusters = hacd.GetNClusters();
    const shapes = [];
    for (let i = 0; i < nClusters; i++) {
      const hull = new Ammo.btConvexHullShape();
      hull.setMargin(options.margin);
      const nPoints = hacd.GetNPointsCH(i);
      const nTriangles = hacd.GetNTrianglesCH(i);
      const hullPoints = Ammo._malloc(nPoints * 3 * 8);
      const hullTriangles = Ammo._malloc(nTriangles * 3 * 4);
      hacd.GetCH(i, hullPoints, hullTriangles);
      const pptr2 = hullPoints / 8;
      for (let pi = 0; pi < nPoints; pi++) {
        const btVertex = new Ammo.btVector3();
        const px = Ammo.HEAPF64[pptr2 + pi * 3 + 0];
        const py = Ammo.HEAPF64[pptr2 + pi * 3 + 1];
        const pz = Ammo.HEAPF64[pptr2 + pi * 3 + 2];
        btVertex.setValue(px, py, pz);
        hull.addPoint(btVertex, pi === nPoints - 1);
        Ammo.destroy(btVertex);
      }
      _finishCollisionShape(hull, options, scale);
      shapes.push(hull);
    }
    return shapes;
  };
}();
var createVHACDShapes = function() {
  const vector = new Vector3();
  const center = new Vector3();
  const matrix = new Matrix4();
  return function(vertices, matrices, indexes, matrixWorld, options = {}) {
    options.type = TYPE.VHACD;
    _setOptions(options);
    if (options.fit === FIT.MANUAL) {
      console.warn("cannot use fit: manual with type: vhacd");
      return [];
    }
    if (!Ammo.hasOwnProperty("VHACD")) {
      console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version.");
      return [];
    }
    const bounds = _computeBounds(vertices, matrices);
    const scale = _computeScale(matrixWorld, options);
    let vertexCount = 0;
    let triCount = 0;
    center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);
    for (let i = 0; i < vertices.length; i++) {
      vertexCount += vertices[i].length / 3;
      if (indexes && indexes[i]) {
        triCount += indexes[i].length / 3;
      } else {
        triCount += vertices[i].length / 9;
      }
    }
    const vhacd = new Ammo.VHACD();
    const params = new Ammo.Parameters();
    if (options.hasOwnProperty("resolution"))
      params.set_m_resolution(options.resolution);
    if (options.hasOwnProperty("depth"))
      params.set_m_depth(options.depth);
    if (options.hasOwnProperty("concavity"))
      params.set_m_concavity(options.concavity);
    if (options.hasOwnProperty("planeDownsampling"))
      params.set_m_planeDownsampling(options.planeDownsampling);
    if (options.hasOwnProperty("convexhullDownsampling"))
      params.set_m_convexhullDownsampling(options.convexhullDownsampling);
    if (options.hasOwnProperty("alpha"))
      params.set_m_alpha(options.alpha);
    if (options.hasOwnProperty("beta"))
      params.set_m_beta(options.beta);
    if (options.hasOwnProperty("gamma"))
      params.set_m_gamma(options.gamma);
    if (options.hasOwnProperty("pca"))
      params.set_m_pca(options.pca);
    if (options.hasOwnProperty("mode"))
      params.set_m_mode(options.mode);
    if (options.hasOwnProperty("maxNumVerticesPerCH"))
      params.set_m_maxNumVerticesPerCH(options.maxNumVerticesPerCH);
    if (options.hasOwnProperty("minVolumePerCH"))
      params.set_m_minVolumePerCH(options.minVolumePerCH);
    if (options.hasOwnProperty("convexhullApproximation"))
      params.set_m_convexhullApproximation(options.convexhullApproximation);
    if (options.hasOwnProperty("oclAcceleration"))
      params.set_m_oclAcceleration(options.oclAcceleration);
    const points = Ammo._malloc(vertexCount * 3 * 8 + 3);
    const triangles = Ammo._malloc(triCount * 3 * 4);
    let pptr = points / 8, tptr = triangles / 4;
    for (let i = 0; i < vertices.length; i++) {
      const components = vertices[i];
      matrix.fromArray(matrices[i]);
      for (let j = 0; j < components.length; j += 3) {
        vector.set(components[j + 0], components[j + 1], components[j + 2]).applyMatrix4(matrix).sub(center);
        Ammo.HEAPF64[pptr + 0] = vector.x;
        Ammo.HEAPF64[pptr + 1] = vector.y;
        Ammo.HEAPF64[pptr + 2] = vector.z;
        pptr += 3;
      }
      if (indexes[i]) {
        const indices = indexes[i];
        for (let j = 0; j < indices.length; j++) {
          Ammo.HEAP32[tptr] = indices[j];
          tptr++;
        }
      } else {
        for (let j = 0; j < components.length / 3; j++) {
          Ammo.HEAP32[tptr] = j;
          tptr++;
        }
      }
    }
    vhacd.Compute(points, 3, vertexCount, triangles, 3, triCount, params);
    Ammo._free(points);
    Ammo._free(triangles);
    const nHulls = vhacd.GetNConvexHulls();
    const shapes = [];
    const ch = new Ammo.ConvexHull();
    for (let i = 0; i < nHulls; i++) {
      vhacd.GetConvexHull(i, ch);
      const nPoints = ch.get_m_nPoints();
      const hullPoints = ch.get_m_points();
      const hull = new Ammo.btConvexHullShape();
      hull.setMargin(options.margin);
      for (let pi = 0; pi < nPoints; pi++) {
        const btVertex = new Ammo.btVector3();
        const px = ch.get_m_points(pi * 3 + 0);
        const py = ch.get_m_points(pi * 3 + 1);
        const pz = ch.get_m_points(pi * 3 + 2);
        btVertex.setValue(px, py, pz);
        hull.addPoint(btVertex, pi === nPoints - 1);
        Ammo.destroy(btVertex);
      }
      _finishCollisionShape(hull, options, scale);
      shapes.push(hull);
    }
    Ammo.destroy(ch);
    Ammo.destroy(vhacd);
    return shapes;
  };
}();
var createTriMeshShape = function() {
  const va = new Vector3();
  const vb = new Vector3();
  const vc = new Vector3();
  const matrix = new Matrix4();
  return function(vertices, matrices, indexes, matrixWorld, options = {}) {
    options.type = TYPE.MESH;
    _setOptions(options);
    if (options.fit === FIT.MANUAL) {
      console.warn("cannot use fit: manual with type: mesh");
      return null;
    }
    const scale = _computeScale(matrixWorld, options);
    const bta = new Ammo.btVector3();
    const btb = new Ammo.btVector3();
    const btc = new Ammo.btVector3();
    const triMesh = new Ammo.btTriangleMesh(true, false);
    for (let i = 0; i < vertices.length; i++) {
      const components = vertices[i];
      const index = indexes[i] ? indexes[i] : null;
      matrix.fromArray(matrices[i]);
      if (index) {
        for (let j = 0; j < index.length; j += 3) {
          const ai = index[j] * 3;
          const bi = index[j + 1] * 3;
          const ci = index[j + 2] * 3;
          va.set(components[ai], components[ai + 1], components[ai + 2]).applyMatrix4(matrix);
          vb.set(components[bi], components[bi + 1], components[bi + 2]).applyMatrix4(matrix);
          vc.set(components[ci], components[ci + 1], components[ci + 2]).applyMatrix4(matrix);
          bta.setValue(va.x, va.y, va.z);
          btb.setValue(vb.x, vb.y, vb.z);
          btc.setValue(vc.x, vc.y, vc.z);
          triMesh.addTriangle(bta, btb, btc, false);
        }
      } else {
        for (let j = 0; j < components.length; j += 9) {
          va.set(components[j + 0], components[j + 1], components[j + 2]).applyMatrix4(matrix);
          vb.set(components[j + 3], components[j + 4], components[j + 5]).applyMatrix4(matrix);
          vc.set(components[j + 6], components[j + 7], components[j + 8]).applyMatrix4(matrix);
          bta.setValue(va.x, va.y, va.z);
          btb.setValue(vb.x, vb.y, vb.z);
          btc.setValue(vc.x, vc.y, vc.z);
          triMesh.addTriangle(bta, btb, btc, false);
        }
      }
    }
    const localScale = new Ammo.btVector3(scale.x, scale.y, scale.z);
    triMesh.setScaling(localScale);
    Ammo.destroy(localScale);
    let collisionShape;
    if (options.concave)
      collisionShape = new Ammo.btBvhTriangleMeshShape(triMesh, true, true);
    else
      collisionShape = new Ammo.btConvexTriangleMeshShape(triMesh, true);
    collisionShape.resources = [triMesh];
    Ammo.destroy(bta);
    Ammo.destroy(btb);
    Ammo.destroy(btc);
    _finishCollisionShape(collisionShape, options);
    return collisionShape;
  };
}();
function _setOptions(options) {
  options.type = options.type || TYPE.HULL;
  options.margin = options.hasOwnProperty("margin") ? options.margin : 0.01;
  return;
}
var _finishCollisionShape = function(collisionShape, options, scale) {
  return;
};
var iterateGeometries = function() {
  const inverse = new Matrix4();
  return function(root, options, cb) {
    if (parseInt(REVISION) >= 123)
      inverse.copy(root.matrixWorld).invert();
    else
      inverse.getInverse(root.matrixWorld);
    const scale = new Vector3();
    scale.setFromMatrixScale(root.matrixWorld);
    root.traverse((mesh) => {
      const transform = new Matrix4();
      if (mesh.isMesh && // MOD (yandeu): No need to check if name is 'Sky'
      // mesh.name !== 'Sky' &&
      (options.includeInvisible || mesh.el && mesh.el.object3D.visible || mesh.visible)) {
        if (mesh === root) {
          transform.identity();
        } else {
          mesh.updateWorldMatrix(true);
          transform.multiplyMatrices(inverse, mesh.matrixWorld);
        }
        cb(mesh.geometry.isBufferGeometry ? mesh.geometry.attributes.position.array : mesh.geometry.vertices, transform.elements, mesh.geometry.index ? mesh.geometry.index.array : null);
      }
    });
  };
}();
var _computeScale = function() {
  const matrix = new Matrix4();
  return function(matrixWorld, options = {}) {
    const scale = new Vector3(1, 1, 1);
    if (options.fit === FIT.ALL) {
      matrix.fromArray(matrixWorld);
      scale.setFromMatrixScale(matrix);
    }
    return scale;
  };
}();
var _computeRadius = function() {
  const center = new Vector3();
  return function(vertices, matrices, bounds) {
    let maxRadiusSq = 0;
    let { x: cx, y: cy, z: cz } = bounds.getCenter(center);
    _iterateVertices(vertices, matrices, (v) => {
      const dx = cx - v.x;
      const dy = cy - v.y;
      const dz = cz - v.z;
      maxRadiusSq = Math.max(maxRadiusSq, dx * dx + dy * dy + dz * dz);
    });
    return Math.sqrt(maxRadiusSq);
  };
}();
var _computeBounds = function(vertices, matrices) {
  const bounds = new Box3();
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  bounds.min.set(0, 0, 0);
  bounds.max.set(0, 0, 0);
  _iterateVertices(vertices, matrices, (v) => {
    if (v.x < minX)
      minX = v.x;
    if (v.y < minY)
      minY = v.y;
    if (v.z < minZ)
      minZ = v.z;
    if (v.x > maxX)
      maxX = v.x;
    if (v.y > maxY)
      maxY = v.y;
    if (v.z > maxZ)
      maxZ = v.z;
  });
  bounds.min.set(minX, minY, minZ);
  bounds.max.set(maxX, maxY, maxZ);
  return bounds;
};
var _iterateVertices = function() {
  const vertex = new Vector3();
  const matrix = new Matrix4();
  return function(vertices, matrices, cb) {
    for (let i = 0; i < vertices.length; i++) {
      matrix.fromArray(matrices[i]);
      for (let j = 0; j < vertices[i].length; j += 3) {
        vertex.set(vertices[i][j], vertices[i][j + 1], vertices[i][j + 2]).applyMatrix4(matrix);
        cb(vertex);
      }
    }
  };
}();

// node_modules/@enable3d/ammo-physics/dist/torusShape.js
var createTorusShape = (config, quat) => {
  const { radius = 1, tube = 0.4, tubularSegments = 8 } = config;
  const SIMD_PI = Math.PI;
  const subdivisions = tubularSegments;
  const gap = Math.sqrt(2 * tube * tube - 2 * tube * tube * Math.cos(2 * SIMD_PI / subdivisions));
  const btHalfExtents = new Ammo.btVector3(tube, SIMD_PI / subdivisions + 0.5 * gap, tube);
  const cylinderShape = new Ammo.btCylinderShape(btHalfExtents);
  cylinderShape.setMargin(0.05);
  const compoundShape = new Ammo.btCompoundShape();
  const forward = new Ammo.btVector3(0, 0, 1);
  const side = new Ammo.btVector3(0, radius, 0);
  const rotation = new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w);
  for (let x = 0; x < subdivisions; x++) {
    const angle = x * 2 * SIMD_PI / subdivisions;
    const position = side.rotate(forward, angle);
    const transform = new Ammo.btTransform();
    rotation.setRotation(forward, angle + Math.PI / 2);
    transform.setIdentity();
    transform.setOrigin(position);
    transform.setRotation(rotation);
    compoundShape.addChildShape(transform, cylinderShape);
  }
  return compoundShape;
};

// node_modules/@enable3d/common/dist/defaultMaterial.js
var DefaultMaterial = class {
  constructor() {
    this._defaultMaterial = new MeshLambertMaterial({ color: 13421772 });
  }
  get() {
    return this._defaultMaterial;
  }
};
var defaultMaterial_default = DefaultMaterial;

// node_modules/@enable3d/common/dist/factories.js
var Factories = class {
  constructor(scene) {
    this.scene = scene;
    this.isHeadless = scene === "headless" ? true : false;
    this.defaultMaterial = new defaultMaterial_default();
  }
  get make() {
    return {
      plane: (planeConfig = {}, materialConfig = {}) => this.makePlane(planeConfig, materialConfig),
      box: (boxConfig = {}, materialConfig = {}) => this.makeBox(boxConfig, materialConfig),
      sphere: (sphereConfig = {}, materialConfig = {}) => this.makeSphere(sphereConfig, materialConfig),
      capsule: (capsuleConfig = {}, materialConfig = {}) => this.makeCapsule(capsuleConfig, materialConfig),
      cylinder: (cylinderConfig = {}, materialConfig = {}) => this.makeCylinder(cylinderConfig, materialConfig),
      cone: (coneConfig = {}, materialConfig = {}) => this.makeCone(coneConfig, materialConfig),
      torus: (torusConfig = {}, materialConfig = {}) => this.makeTorus(torusConfig, materialConfig),
      extrude: (extrudeConfig, materialConfig = {}) => this.makeExtrude(extrudeConfig, materialConfig)
    };
  }
  get add() {
    return {
      // effectComposer: () => this.addEffectComposer(),
      mesh: (mesh) => this.addMesh(mesh),
      // group: (...children) => this.addGroup(children),
      existing: (object) => this.addExisting(object),
      //  Geometry
      plane: (planeConfig = {}, materialConfig = {}) => this.addPlane(planeConfig, materialConfig),
      box: (boxConfig = {}, materialConfig = {}) => this.addBox(boxConfig, materialConfig),
      ground: (groundConfig, materialConfig = {}) => this.addGround(groundConfig, materialConfig),
      //...
      sphere: (sphereConfig = {}, materialConfig = {}) => this.addSphere(sphereConfig, materialConfig),
      capsule: (capsuleConfig = {}, materialConfig = {}) => this.addCapsule(capsuleConfig, materialConfig),
      cylinder: (cylinderConfig = {}, materialConfig = {}) => this.addCylinder(cylinderConfig, materialConfig),
      cone: (coneConfig = {}, materialConfig = {}) => this.addCone(coneConfig, materialConfig),
      torus: (torusConfig = {}, materialConfig = {}) => this.addTorus(torusConfig, materialConfig),
      extrude: (extrudeConfig, materialConfig = {}) => this.addExtrude(extrudeConfig, materialConfig),
      //...
      material: (materialConfig = {}) => this.addMaterial(materialConfig)
    };
  }
  addExisting(...object) {
    if (this.scene === "headless")
      return;
    this.scene.add(...object);
  }
  addMesh(mesh) {
    if (Array.isArray(mesh)) {
      for (let i = 0; i < mesh.length; i++) {
        this.addExisting(mesh[i]);
      }
    } else {
      this.addExisting(mesh);
    }
    return this;
  }
  createMesh(geometry, material, position) {
    const { x = 0, y = 0, z = 0 } = position;
    let obj;
    switch (!Array.isArray(material) && material.type) {
      case "LineBasicMaterial":
        obj = new Line(geometry, material);
        break;
      case "PointsMaterial":
        obj = new Points(geometry, material);
        break;
      default:
        obj = new ExtendedMesh(geometry, material);
        break;
    }
    obj.position.set(x, y, z);
    obj.castShadow = obj.receiveShadow = true;
    return obj;
  }
  makeExtrude(extrudeConfig, materialConfig) {
    const { x, y, z, name, shape, autoCenter = true, breakable = false, ...rest } = extrudeConfig;
    const { depth = 1, bevelEnabled = false } = rest;
    const geometry = new ExtrudeGeometry(shape, { depth, bevelEnabled, ...rest });
    const material = this.addMaterial(materialConfig);
    const mesh = this.createMesh(geometry, material, { x, y, z });
    if (autoCenter)
      mesh.geometry.center();
    mesh.name = name || `body_id_${mesh.id}`;
    mesh.shape = "extrude";
    return mesh;
  }
  addExtrude(extrudeConfig, materialConfig = {}) {
    const obj = this.makeExtrude(extrudeConfig, materialConfig);
    this.addExisting(obj);
    return obj;
  }
  makePlane(planeConfig, materialConfig) {
    const { x, y, z, name, breakable = false, ...rest } = planeConfig;
    const geometry = new PlaneGeometry(rest.width || 1, rest.height || 1, rest.widthSegments || 1, rest.heightSegments || 1);
    const material = this.addMaterial(materialConfig);
    material.side = DoubleSide;
    const mesh = this.createMesh(geometry, material, { x, y, z });
    mesh.name = name || `body_id_${mesh.id}`;
    mesh.shape = "plane";
    return mesh;
  }
  addPlane(planeConfig, materialConfig) {
    const obj = this.makePlane(planeConfig, materialConfig);
    this.addExisting(obj);
    return obj;
  }
  makeSphere(sphereConfig, materialConfig) {
    const { x, y, z, name, breakable = false, ...rest } = sphereConfig;
    const geometry = new SphereGeometry(rest.radius || 1, rest.widthSegments || 16, rest.heightSegments || 12, rest.phiStart || void 0, rest.phiLength || void 0, rest.thetaStart || void 0, rest.thetaLength || void 0);
    const material = this.addMaterial(materialConfig);
    const mesh = this.createMesh(geometry, material, { x, y, z });
    mesh.name = name || `body_id_${mesh.id}`;
    mesh.shape = "sphere";
    return mesh;
  }
  addSphere(sphereConfig = {}, materialConfig = {}) {
    const obj = this.makeSphere(sphereConfig, materialConfig);
    this.addExisting(obj);
    return obj;
  }
  makeBox(boxConfig, materialConfig) {
    const { x, y, z, name, breakable = false, ...rest } = boxConfig;
    const geometry = new BoxGeometry(rest.width || 1, rest.height || 1, rest.depth || 1, rest.widthSegments || void 0, rest.heightSegments || void 0, rest.depthSegments || void 0);
    const material = this.addMaterial(materialConfig);
    const mesh = this.createMesh(geometry, material, { x, y, z });
    mesh.name = name || `body_id_${mesh.id}`;
    mesh.shape = "box";
    return mesh;
  }
  addBox(boxConfig = {}, materialConfig = {}) {
    const obj = this.makeBox(boxConfig, materialConfig);
    this.addExisting(obj);
    return obj;
  }
  addGround(groundConfig, materialConfig = {}) {
    const obj = this.makeBox(groundConfig, materialConfig);
    obj.rotateX(MathUtils.degToRad(90));
    this.addExisting(obj);
    return obj;
  }
  makeCapsule(capsuleConfig = {}, materialConfig = {}) {
    const { x, y, z, name, breakable = false, ...rest } = capsuleConfig;
    const geometry = new CapsuleGeometry(rest.radius || 0.5, rest.length || 1, rest.capSegments || 4, rest.radialSegments || 16);
    const material = this.addMaterial(materialConfig);
    const mesh = this.createMesh(geometry, material, { x, y, z });
    mesh.name = name || `body_id_${mesh.id}`;
    mesh.shape = "capsule";
    return mesh;
  }
  addCapsule(capsuleConfig = {}, materialConfig = {}) {
    const obj = this.makeCapsule(capsuleConfig, materialConfig);
    this.addExisting(obj);
    return obj;
  }
  makeCylinder(cylinderConfig = {}, materialConfig = {}) {
    const { x, y, z, name, breakable = false, ...rest } = cylinderConfig;
    const geometry = new CylinderGeometry(rest.radiusTop || 1, rest.radiusBottom || 1, rest.height || 1, rest.radiusSegments || void 0, rest.heightSegments || void 0, rest.openEnded || void 0, rest.thetaStart || void 0, rest.thetaLength || void 0);
    const material = this.addMaterial(materialConfig);
    const mesh = this.createMesh(geometry, material, { x, y, z });
    mesh.name = name || `body_id_${mesh.id}`;
    mesh.shape = "cylinder";
    return mesh;
  }
  addCylinder(cylinderConfig = {}, materialConfig = {}) {
    const obj = this.makeCylinder(cylinderConfig, materialConfig);
    this.addExisting(obj);
    return obj;
  }
  makeCone(coneConfig = {}, materialConfig = {}) {
    const { x, y, z, name, breakable = false, ...rest } = coneConfig;
    const geometry = new ConeGeometry(rest.radius || 1, rest.height || 1, rest.radiusSegments || 8, rest.heightSegments || 1, rest.openEnded || false, rest.thetaStart || 0, rest.thetaLength || 2 * Math.PI);
    const material = this.addMaterial(materialConfig);
    const mesh = this.createMesh(geometry, material, { x, y, z });
    mesh.name = name || `body_id_${mesh.id}`;
    mesh.shape = "cone";
    return mesh;
  }
  addCone(coneConfig = {}, materialConfig = {}) {
    const obj = this.makeCone(coneConfig, materialConfig);
    this.addExisting(obj);
    return obj;
  }
  // https://threejs.org/docs/index.html#api/en/geometries/TorusBufferGeometry
  makeTorus(torusConfig = {}, materialConfig = {}) {
    const { x, y, z, name, breakable = false, ...rest } = torusConfig;
    const geometry = new TorusGeometry(rest.radius || void 0, rest.tube || void 0, rest.radialSegments || void 0, rest.tubularSegments || void 0, rest.arc || void 0);
    const material = this.addMaterial(materialConfig);
    const mesh = this.createMesh(geometry, material, { x, y, z });
    mesh.name = name || `body_id_${mesh.id}`;
    mesh.shape = "torus";
    return mesh;
  }
  addTorus(torusConfig = {}, materialConfig = {}) {
    const obj = this.makeTorus(torusConfig, materialConfig);
    this.addExisting(obj);
    return obj;
  }
  addMaterial(materialConfig = {}) {
    const type = Object.keys(materialConfig)[0];
    let material;
    if (this.scene === "headless")
      return this.defaultMaterial.get();
    switch (type) {
      case "basic":
        material = new MeshBasicMaterial(materialConfig.basic);
        break;
      case "normal":
        material = new MeshNormalMaterial(materialConfig.normal);
        break;
      case "standard":
        material = new MeshStandardMaterial(materialConfig.standard);
        break;
      case "lambert":
        material = new MeshLambertMaterial(materialConfig.lambert);
        break;
      case "phong":
        material = new MeshPhongMaterial(materialConfig.phong);
        break;
      case "physical":
        if (typeof materialConfig.physical !== "undefined") {
          material = new MeshPhysicalMaterial(materialConfig.physical);
        } else {
          logger("You need to pass parameters to the physical material. (Fallback to default material)");
          material = this.defaultMaterial.get();
        }
        break;
      case "toon":
        material = new MeshToonMaterial(materialConfig.toon);
        break;
      case "line":
        material = new LineBasicMaterial(materialConfig.line);
        break;
      case "points":
        material = new PointsMaterial(materialConfig.points);
        break;
      case "custom":
        material = materialConfig.custom || this.defaultMaterial.get();
        break;
      default:
        material = this.defaultMaterial.get();
        break;
    }
    return material;
  }
};

// node_modules/@enable3d/ammo-physics/dist/collisionEvents.js
var import_events2 = __toESM(require_cjs());
var CollisionEvents = class extends import_events2.Events {
  addCollider(object1, object2, eventCallback) {
    if (!object1.body || !object2.body)
      return;
    object1.body.checkCollisions = true;
    object2.body.checkCollisions = true;
    this.on("collision", (data) => {
      var _a, _b;
      const { bodies, event } = data;
      if (((_a = bodies[0]) == null ? void 0 : _a.name) && ((_b = bodies[1]) == null ? void 0 : _b.name) && (object1 == null ? void 0 : object1.name) && (object2 == null ? void 0 : object2.name)) {
        if (bodies[0].name === object1.name && bodies[1].name === object2.name)
          eventCallback(event);
        else if (bodies[1].name === object1.name && bodies[0].name === object2.name)
          eventCallback(event);
      }
    });
  }
};

// node_modules/@enable3d/ammo-physics/dist/debugDrawer.js
var AmmoDebugConstants = {
  NoDebug: 0,
  DrawWireframe: 1,
  DrawAabb: 2,
  DrawFeaturesText: 4,
  DrawContactPoints: 8,
  NoDeactivation: 16,
  NoHelpText: 32,
  DrawText: 64,
  ProfileTimings: 128,
  EnableSatComparison: 256,
  DisableBulletLCP: 512,
  EnableCCD: 1024,
  DrawConstraints: 1 << 11,
  DrawConstraintLimits: 1 << 12,
  FastWireframe: 1 << 13,
  DrawNormals: 1 << 14,
  DrawOnTop: 1 << 15,
  MAX_DEBUG_DRAW_MODE: 4294967295
};
var DebugDrawer = class {
  constructor(scene, world, options = {}) {
    this.scene = scene;
    this.world = world;
    this.options = options;
    this.debugDrawMode = options.debugDrawMode || AmmoDebugConstants.DrawWireframe;
    const drawOnTop = this.debugDrawMode & AmmoDebugConstants.DrawOnTop || false;
    const maxBufferSize = options.maxBufferSize || 1e6;
    this.geometry = new BufferGeometry();
    const vertices = new Float32Array(maxBufferSize * 3);
    const colors = new Float32Array(maxBufferSize * 3);
    this.geometry.setAttribute("position", new BufferAttribute(vertices, 3).setUsage(StaticDrawUsage));
    this.geometry.setAttribute("color", new BufferAttribute(colors, 3).setUsage(StaticDrawUsage));
    this.index = 0;
    const material = new LineBasicMaterial({
      vertexColors: true,
      depthTest: !drawOnTop
    });
    this.mesh = new LineSegments(this.geometry, material);
    if (drawOnTop)
      this.mesh.renderOrder = 999;
    this.mesh.frustumCulled = false;
    this.enabled = false;
    this.debugDrawer = new Ammo.DebugDrawer();
    this.debugDrawer.drawLine = this.drawLine.bind(this);
    this.debugDrawer.drawContactPoint = this.drawContactPoint.bind(this);
    this.debugDrawer.reportErrorWarning = this.reportErrorWarning.bind(this);
    this.debugDrawer.draw3dText = this.draw3dText.bind(this);
    this.debugDrawer.setDebugMode = this.setDebugMode.bind(this);
    this.debugDrawer.getDebugMode = this.getDebugMode.bind(this);
    this.world.setDebugDrawer(this.debugDrawer);
  }
  enable() {
    this.enabled = true;
    this.scene.add(this.mesh);
  }
  disable() {
    this.enabled = false;
    this.scene.remove(this.mesh);
  }
  update() {
    if (!this.enabled) {
      return;
    }
    if (this.index != 0) {
      this.geometry.attributes.position.needsUpdate = true;
      this.geometry.attributes.color.needsUpdate = true;
    }
    this.index = 0;
    this.world.debugDrawWorld();
    this.geometry.setDrawRange(0, this.index);
  }
  drawLine(from, to, color) {
    const heap = Ammo.HEAPF32;
    const r = heap[(color + 0) / 4];
    const g = heap[(color + 4) / 4];
    const b = heap[(color + 8) / 4];
    const fromX = heap[(from + 0) / 4];
    const fromY = heap[(from + 4) / 4];
    const fromZ = heap[(from + 8) / 4];
    this.geometry.attributes.position.setXYZ(this.index, fromX, fromY, fromZ);
    this.geometry.attributes.color.setXYZ(this.index++, r, g, b);
    const toX = heap[(to + 0) / 4];
    const toY = heap[(to + 4) / 4];
    const toZ = heap[(to + 8) / 4];
    this.geometry.attributes.position.setXYZ(this.index, toX, toY, toZ);
    this.geometry.attributes.color.setXYZ(this.index++, r, g, b);
  }
  //TODO: figure out how to make lifeTime work
  drawContactPoint(pointOnB, normalOnB, distance, _lifeTime, color) {
    const heap = Ammo.HEAPF32;
    const r = heap[(color + 0) / 4];
    const g = heap[(color + 4) / 4];
    const b = heap[(color + 8) / 4];
    const x = heap[(pointOnB + 0) / 4];
    const y = heap[(pointOnB + 4) / 4];
    const z = heap[(pointOnB + 8) / 4];
    this.geometry.attributes.position.setXYZ(this.index, x, y, z);
    this.geometry.attributes.color.setXYZ(this.index++, r, g, b);
    const dx = heap[(normalOnB + 0) / 4] * distance;
    const dy = heap[(normalOnB + 4) / 4] * distance;
    const dz = heap[(normalOnB + 8) / 4] * distance;
    this.geometry.attributes.position.setXYZ(this.index, x + dx, y + dy, z + dz);
    this.geometry.attributes.color.setXYZ(this.index++, r, g, b);
  }
  reportErrorWarning(warningString) {
    if (Ammo.hasOwnProperty("Pointer_stringify")) {
      console.warn(Ammo.Pointer_stringify(warningString));
    } else if (!this.warnedOnce) {
      this.warnedOnce = true;
      console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag");
    }
  }
  draw3dText(_location, _textString) {
    console.warn("TODO: draw3dText");
  }
  setDebugMode(debugMode) {
    this.debugDrawMode = debugMode;
  }
  getDebugMode() {
    return this.debugDrawMode;
  }
};
var debugDrawer_default = DebugDrawer;

// node_modules/three/examples/jsm/math/ConvexHull.js
var Visible = 0;
var Deleted = 1;
var _v1 = new Vector3();
var _line3 = new Line3();
var _plane = new Plane();
var _closestPoint = new Vector3();
var _triangle = new Triangle();
var ConvexHull = class {
  constructor() {
    this.tolerance = -1;
    this.faces = [];
    this.newFaces = [];
    this.assigned = new VertexList();
    this.unassigned = new VertexList();
    this.vertices = [];
  }
  setFromPoints(points) {
    if (points.length >= 4) {
      this.makeEmpty();
      for (let i = 0, l = points.length; i < l; i++) {
        this.vertices.push(new VertexNode(points[i]));
      }
      this.compute();
    }
    return this;
  }
  setFromObject(object) {
    const points = [];
    object.updateMatrixWorld(true);
    object.traverse(function(node) {
      const geometry = node.geometry;
      if (geometry !== void 0) {
        const attribute = geometry.attributes.position;
        if (attribute !== void 0) {
          for (let i = 0, l = attribute.count; i < l; i++) {
            const point = new Vector3();
            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
            points.push(point);
          }
        }
      }
    });
    return this.setFromPoints(points);
  }
  containsPoint(point) {
    const faces = this.faces;
    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];
      if (face.distanceToPoint(point) > this.tolerance)
        return false;
    }
    return true;
  }
  intersectRay(ray, target) {
    const faces = this.faces;
    let tNear = -Infinity;
    let tFar = Infinity;
    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];
      const vN = face.distanceToPoint(ray.origin);
      const vD = face.normal.dot(ray.direction);
      if (vN > 0 && vD >= 0)
        return null;
      const t = vD !== 0 ? -vN / vD : 0;
      if (t <= 0)
        continue;
      if (vD > 0) {
        tFar = Math.min(t, tFar);
      } else {
        tNear = Math.max(t, tNear);
      }
      if (tNear > tFar) {
        return null;
      }
    }
    if (tNear !== -Infinity) {
      ray.at(tNear, target);
    } else {
      ray.at(tFar, target);
    }
    return target;
  }
  intersectsRay(ray) {
    return this.intersectRay(ray, _v1) !== null;
  }
  makeEmpty() {
    this.faces = [];
    this.vertices = [];
    return this;
  }
  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
  addVertexToFace(vertex, face) {
    vertex.face = face;
    if (face.outside === null) {
      this.assigned.append(vertex);
    } else {
      this.assigned.insertBefore(face.outside, vertex);
    }
    face.outside = vertex;
    return this;
  }
  // Removes a vertex from the 'assigned' list of vertices and from the given face
  removeVertexFromFace(vertex, face) {
    if (vertex === face.outside) {
      if (vertex.next !== null && vertex.next.face === face) {
        face.outside = vertex.next;
      } else {
        face.outside = null;
      }
    }
    this.assigned.remove(vertex);
    return this;
  }
  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list
  removeAllVerticesFromFace(face) {
    if (face.outside !== null) {
      const start = face.outside;
      let end = face.outside;
      while (end.next !== null && end.next.face === face) {
        end = end.next;
      }
      this.assigned.removeSubList(start, end);
      start.prev = end.next = null;
      face.outside = null;
      return start;
    }
  }
  // Removes all the visible vertices that 'face' is able to see
  deleteFaceVertices(face, absorbingFace) {
    const faceVertices = this.removeAllVerticesFromFace(face);
    if (faceVertices !== void 0) {
      if (absorbingFace === void 0) {
        this.unassigned.appendChain(faceVertices);
      } else {
        let vertex = faceVertices;
        do {
          const nextVertex = vertex.next;
          const distance = absorbingFace.distanceToPoint(vertex.point);
          if (distance > this.tolerance) {
            this.addVertexToFace(vertex, absorbingFace);
          } else {
            this.unassigned.append(vertex);
          }
          vertex = nextVertex;
        } while (vertex !== null);
      }
    }
    return this;
  }
  // Reassigns as many vertices as possible from the unassigned list to the new faces
  resolveUnassignedPoints(newFaces) {
    if (this.unassigned.isEmpty() === false) {
      let vertex = this.unassigned.first();
      do {
        const nextVertex = vertex.next;
        let maxDistance = this.tolerance;
        let maxFace = null;
        for (let i = 0; i < newFaces.length; i++) {
          const face = newFaces[i];
          if (face.mark === Visible) {
            const distance = face.distanceToPoint(vertex.point);
            if (distance > maxDistance) {
              maxDistance = distance;
              maxFace = face;
            }
            if (maxDistance > 1e3 * this.tolerance)
              break;
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
        vertex = nextVertex;
      } while (vertex !== null);
    }
    return this;
  }
  // Computes the extremes of a simplex which will be the initial hull
  computeExtremes() {
    const min = new Vector3();
    const max = new Vector3();
    const minVertices = [];
    const maxVertices = [];
    for (let i = 0; i < 3; i++) {
      minVertices[i] = maxVertices[i] = this.vertices[0];
    }
    min.copy(this.vertices[0].point);
    max.copy(this.vertices[0].point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = this.vertices[i];
      const point = vertex.point;
      for (let j = 0; j < 3; j++) {
        if (point.getComponent(j) < min.getComponent(j)) {
          min.setComponent(j, point.getComponent(j));
          minVertices[j] = vertex;
        }
      }
      for (let j = 0; j < 3; j++) {
        if (point.getComponent(j) > max.getComponent(j)) {
          max.setComponent(j, point.getComponent(j));
          maxVertices[j] = vertex;
        }
      }
    }
    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));
    return { min: minVertices, max: maxVertices };
  }
  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull
  computeInitialHull() {
    const vertices = this.vertices;
    const extremes = this.computeExtremes();
    const min = extremes.min;
    const max = extremes.max;
    let maxDistance = 0;
    let index = 0;
    for (let i = 0; i < 3; i++) {
      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);
      if (distance > maxDistance) {
        maxDistance = distance;
        index = i;
      }
    }
    const v0 = min[index];
    const v1 = max[index];
    let v2;
    let v3;
    maxDistance = 0;
    _line3.set(v0.point, v1.point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1) {
        _line3.closestPointToPoint(vertex.point, true, _closestPoint);
        const distance = _closestPoint.distanceToSquared(vertex.point);
        if (distance > maxDistance) {
          maxDistance = distance;
          v2 = vertex;
        }
      }
    }
    maxDistance = -1;
    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {
        const distance = Math.abs(_plane.distanceToPoint(vertex.point));
        if (distance > maxDistance) {
          maxDistance = distance;
          v3 = vertex;
        }
      }
    }
    const faces = [];
    if (_plane.distanceToPoint(v3.point) < 0) {
      faces.push(
        Face.create(v0, v1, v2),
        Face.create(v3, v1, v0),
        Face.create(v3, v2, v1),
        Face.create(v3, v0, v2)
      );
      for (let i = 0; i < 3; i++) {
        const j = (i + 1) % 3;
        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));
        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));
      }
    } else {
      faces.push(
        Face.create(v0, v2, v1),
        Face.create(v3, v0, v1),
        Face.create(v3, v1, v2),
        Face.create(v3, v2, v0)
      );
      for (let i = 0; i < 3; i++) {
        const j = (i + 1) % 3;
        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));
        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));
      }
    }
    for (let i = 0; i < 4; i++) {
      this.faces.push(faces[i]);
    }
    for (let i = 0, l = vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {
        maxDistance = this.tolerance;
        let maxFace = null;
        for (let j = 0; j < 4; j++) {
          const distance = this.faces[j].distanceToPoint(vertex.point);
          if (distance > maxDistance) {
            maxDistance = distance;
            maxFace = this.faces[j];
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
      }
    }
    return this;
  }
  // Removes inactive faces
  reindexFaces() {
    const activeFaces = [];
    for (let i = 0; i < this.faces.length; i++) {
      const face = this.faces[i];
      if (face.mark === Visible) {
        activeFaces.push(face);
      }
    }
    this.faces = activeFaces;
    return this;
  }
  // Finds the next vertex to create faces with the current hull
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let eyeVertex, maxDistance = 0;
      const eyeFace = this.assigned.first().face;
      let vertex = eyeFace.outside;
      do {
        const distance = eyeFace.distanceToPoint(vertex.point);
        if (distance > maxDistance) {
          maxDistance = distance;
          eyeVertex = vertex;
        }
        vertex = vertex.next;
      } while (vertex !== null && vertex.face === eyeFace);
      return eyeVertex;
    }
  }
  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.
  computeHorizon(eyePoint, crossEdge, face, horizon) {
    this.deleteFaceVertices(face);
    face.mark = Deleted;
    let edge;
    if (crossEdge === null) {
      edge = crossEdge = face.getEdge(0);
    } else {
      edge = crossEdge.next;
    }
    do {
      const twinEdge = edge.twin;
      const oppositeFace = twinEdge.face;
      if (oppositeFace.mark === Visible) {
        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
        } else {
          horizon.push(edge);
        }
      }
      edge = edge.next;
    } while (edge !== crossEdge);
    return this;
  }
  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
  addAdjoiningFace(eyeVertex, horizonEdge) {
    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
    this.faces.push(face);
    face.getEdge(-1).setTwin(horizonEdge.twin);
    return face.getEdge(0);
  }
  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right
  addNewFaces(eyeVertex, horizon) {
    this.newFaces = [];
    let firstSideEdge = null;
    let previousSideEdge = null;
    for (let i = 0; i < horizon.length; i++) {
      const horizonEdge = horizon[i];
      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
      if (firstSideEdge === null) {
        firstSideEdge = sideEdge;
      } else {
        sideEdge.next.setTwin(previousSideEdge);
      }
      this.newFaces.push(sideEdge.face);
      previousSideEdge = sideEdge;
    }
    firstSideEdge.next.setTwin(previousSideEdge);
    return this;
  }
  // Adds a vertex to the hull
  addVertexToHull(eyeVertex) {
    const horizon = [];
    this.unassigned.clear();
    this.removeVertexFromFace(eyeVertex, eyeVertex.face);
    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
    this.addNewFaces(eyeVertex, horizon);
    this.resolveUnassignedPoints(this.newFaces);
    return this;
  }
  cleanup() {
    this.assigned.clear();
    this.unassigned.clear();
    this.newFaces = [];
    return this;
  }
  compute() {
    let vertex;
    this.computeInitialHull();
    while ((vertex = this.nextVertexToAdd()) !== void 0) {
      this.addVertexToHull(vertex);
    }
    this.reindexFaces();
    this.cleanup();
    return this;
  }
};
var Face = class _Face {
  constructor() {
    this.normal = new Vector3();
    this.midpoint = new Vector3();
    this.area = 0;
    this.constant = 0;
    this.outside = null;
    this.mark = Visible;
    this.edge = null;
  }
  static create(a, b, c) {
    const face = new _Face();
    const e0 = new HalfEdge(a, face);
    const e1 = new HalfEdge(b, face);
    const e2 = new HalfEdge(c, face);
    e0.next = e2.prev = e1;
    e1.next = e0.prev = e2;
    e2.next = e1.prev = e0;
    face.edge = e0;
    return face.compute();
  }
  getEdge(i) {
    let edge = this.edge;
    while (i > 0) {
      edge = edge.next;
      i--;
    }
    while (i < 0) {
      edge = edge.prev;
      i++;
    }
    return edge;
  }
  compute() {
    const a = this.edge.tail();
    const b = this.edge.head();
    const c = this.edge.next.head();
    _triangle.set(a.point, b.point, c.point);
    _triangle.getNormal(this.normal);
    _triangle.getMidpoint(this.midpoint);
    this.area = _triangle.getArea();
    this.constant = this.normal.dot(this.midpoint);
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) - this.constant;
  }
};
var HalfEdge = class {
  constructor(vertex, face) {
    this.vertex = vertex;
    this.prev = null;
    this.next = null;
    this.twin = null;
    this.face = face;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceTo(head.point);
    }
    return -1;
  }
  lengthSquared() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceToSquared(head.point);
    }
    return -1;
  }
  setTwin(edge) {
    this.twin = edge;
    edge.twin = this;
    return this;
  }
};
var VertexNode = class {
  constructor(point) {
    this.point = point;
    this.prev = null;
    this.next = null;
    this.face = null;
  }
};
var VertexList = class {
  constructor() {
    this.head = null;
    this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    this.head = this.tail = null;
    return this;
  }
  // Inserts a vertex before the target vertex
  insertBefore(target, vertex) {
    vertex.prev = target.prev;
    vertex.next = target;
    if (vertex.prev === null) {
      this.head = vertex;
    } else {
      vertex.prev.next = vertex;
    }
    target.prev = vertex;
    return this;
  }
  // Inserts a vertex after the target vertex
  insertAfter(target, vertex) {
    vertex.prev = target;
    vertex.next = target.next;
    if (vertex.next === null) {
      this.tail = vertex;
    } else {
      vertex.next.prev = vertex;
    }
    target.next = vertex;
    return this;
  }
  // Appends a vertex to the end of the linked list
  append(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    vertex.next = null;
    this.tail = vertex;
    return this;
  }
  // Appends a chain of vertices where 'vertex' is the head.
  appendChain(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    while (vertex.next !== null) {
      vertex = vertex.next;
    }
    this.tail = vertex;
    return this;
  }
  // Removes a vertex from the linked list
  remove(vertex) {
    if (vertex.prev === null) {
      this.head = vertex.next;
    } else {
      vertex.prev.next = vertex.next;
    }
    if (vertex.next === null) {
      this.tail = vertex.prev;
    } else {
      vertex.next.prev = vertex.prev;
    }
    return this;
  }
  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
  removeSubList(a, b) {
    if (a.prev === null) {
      this.head = b.next;
    } else {
      a.prev.next = b.next;
    }
    if (b.next === null) {
      this.tail = a.prev;
    } else {
      b.next.prev = a.prev;
    }
    return this;
  }
  isEmpty() {
    return this.head === null;
  }
};

// node_modules/three/examples/jsm/geometries/ConvexGeometry.js
var ConvexGeometry = class extends BufferGeometry {
  constructor(points = []) {
    super();
    const vertices = [];
    const normals = [];
    const convexHull = new ConvexHull().setFromPoints(points);
    const faces = convexHull.faces;
    for (let i = 0; i < faces.length; i++) {
      const face = faces[i];
      let edge = face.edge;
      do {
        const point = edge.head().point;
        vertices.push(point.x, point.y, point.z);
        normals.push(face.normal.x, face.normal.y, face.normal.z);
        edge = edge.next;
      } while (edge !== face.edge);
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
};

// node_modules/@enable3d/ammo-physics/dist/convexObjectBreaker.js
var newConvexGeometry = (points) => {
  const _newConvexGeometry = window.THREE && window.THREE.ConvexGeometry ? window.THREE.ConvexGeometry : ConvexGeometry;
  return new _newConvexGeometry(points);
};
var ConvexObjectBreaker = function(minSizeForBreak, smallDelta) {
  this.minSizeForBreak = minSizeForBreak || 1.4;
  this.smallDelta = smallDelta || 1e-4;
  this.tempLine1 = new Line3();
  this.tempPlane1 = new Plane();
  this.tempPlane2 = new Plane();
  this.tempPlane_Cut = new Plane();
  this.tempCM1 = new Vector3();
  this.tempCM2 = new Vector3();
  this.tempVector3 = new Vector3();
  this.tempVector3_2 = new Vector3();
  this.tempVector3_3 = new Vector3();
  this.tempVector3_P0 = new Vector3();
  this.tempVector3_P1 = new Vector3();
  this.tempVector3_P2 = new Vector3();
  this.tempVector3_N0 = new Vector3();
  this.tempVector3_N1 = new Vector3();
  this.tempVector3_AB = new Vector3();
  this.tempVector3_CB = new Vector3();
  this.tempResultObjects = { object1: null, object2: null };
  this.segments = [];
  var n = 30 * 30;
  for (var i = 0; i < n; i++)
    this.segments[i] = false;
};
ConvexObjectBreaker.prototype = {
  constructor: ConvexObjectBreaker,
  prepareBreakableObject: function(object, mass, velocity, angularVelocity, breakable) {
    if (!object.geometry.isBufferGeometry) {
      console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.");
    }
    object.userData.ammoPhysicsData = {};
    var ammoPhysicsData = object.userData.ammoPhysicsData;
    ammoPhysicsData.mass = mass;
    ammoPhysicsData.velocity = velocity.clone();
    ammoPhysicsData.angularVelocity = angularVelocity.clone();
    ammoPhysicsData.breakable = breakable;
  },
  /*
   * @param {int} maxRadialIterations Iterations for radial cuts.
   * @param {int} maxRandomIterations Max random iterations for not-radial cuts
   *
   * Returns the array of pieces
   */
  subdivideByImpact: function(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {
    var debris = [];
    var tempPlane1 = this.tempPlane1;
    var tempPlane2 = this.tempPlane2;
    this.tempVector3.addVectors(pointOfImpact, normal);
    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);
    var maxTotalIterations = maxRandomIterations + maxRadialIterations;
    var scope = this;
    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {
      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {
        debris.push(subObject);
        return;
      }
      var angle = Math.PI;
      if (numIterations === 0) {
        tempPlane2.normal.copy(tempPlane1.normal);
        tempPlane2.constant = tempPlane1.constant;
      } else {
        if (numIterations <= maxRadialIterations) {
          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;
          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);
          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);
        } else {
          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;
          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);
          scope.tempVector3_3.copy(normal).add(subObject.position);
          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);
        }
      }
      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);
      var obj1 = scope.tempResultObjects.object1;
      var obj2 = scope.tempResultObjects.object2;
      if (obj1) {
        subdivideRadial(obj1, startAngle, angle, numIterations + 1);
      }
      if (obj2) {
        subdivideRadial(obj2, angle, endAngle, numIterations + 1);
      }
    }
    subdivideRadial(object, 0, 2 * Math.PI, 0);
    return debris;
  },
  cutByPlane: function(object, plane, output) {
    var geometry = object.geometry;
    var coords = geometry.attributes.position.array;
    var normals = geometry.attributes.normal.array;
    var numPoints = coords.length / 3;
    var numFaces = numPoints / 3;
    var indices = geometry.getIndex();
    if (indices) {
      indices = indices.array;
      numFaces = indices.length / 3;
    }
    function getVertexIndex(faceIdx, vert) {
      var idx = faceIdx * 3 + vert;
      return indices ? indices[idx] : idx;
    }
    var points1 = [];
    var points2 = [];
    var delta = this.smallDelta;
    var numPointPairs = numPoints * numPoints;
    for (var i = 0; i < numPointPairs; i++)
      this.segments[i] = false;
    var p0 = this.tempVector3_P0;
    var p1 = this.tempVector3_P1;
    var n0 = this.tempVector3_N0;
    var n1 = this.tempVector3_N1;
    for (var i = 0; i < numFaces - 1; i++) {
      var a1 = getVertexIndex(i, 0);
      var b1 = getVertexIndex(i, 1);
      var c1 = getVertexIndex(i, 2);
      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);
      for (var j = i + 1; j < numFaces; j++) {
        var a2 = getVertexIndex(j, 0);
        var b2 = getVertexIndex(j, 1);
        var c2 = getVertexIndex(j, 2);
        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);
        var coplanar = 1 - n0.dot(n1) < delta;
        if (coplanar) {
          if (a1 === a2 || a1 === b2 || a1 === c2) {
            if (b1 === a2 || b1 === b2 || b1 === c2) {
              this.segments[a1 * numPoints + b1] = true;
              this.segments[b1 * numPoints + a1] = true;
            } else {
              this.segments[c1 * numPoints + a1] = true;
              this.segments[a1 * numPoints + c1] = true;
            }
          } else if (b1 === a2 || b1 === b2 || b1 === c2) {
            this.segments[c1 * numPoints + b1] = true;
            this.segments[b1 * numPoints + c1] = true;
          }
        }
      }
    }
    var localPlane = this.tempPlane_Cut;
    object.updateMatrix();
    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);
    for (var i = 0; i < numFaces; i++) {
      var va = getVertexIndex(i, 0);
      var vb = getVertexIndex(i, 1);
      var vc = getVertexIndex(i, 2);
      for (var segment = 0; segment < 3; segment++) {
        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;
        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;
        var segmentState = this.segments[i0 * numPoints + i1];
        if (segmentState)
          continue;
        this.segments[i0 * numPoints + i1] = true;
        this.segments[i1 * numPoints + i0] = true;
        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);
        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);
        var mark0 = 0;
        var d = localPlane.distanceToPoint(p0);
        if (d > delta) {
          mark0 = 2;
          points2.push(p0.clone());
        } else if (d < -delta) {
          mark0 = 1;
          points1.push(p0.clone());
        } else {
          mark0 = 3;
          points1.push(p0.clone());
          points2.push(p0.clone());
        }
        var mark1 = 0;
        var d = localPlane.distanceToPoint(p1);
        if (d > delta) {
          mark1 = 2;
          points2.push(p1.clone());
        } else if (d < -delta) {
          mark1 = 1;
          points1.push(p1.clone());
        } else {
          mark1 = 3;
          points1.push(p1.clone());
          points2.push(p1.clone());
        }
        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {
          this.tempLine1.start.copy(p0);
          this.tempLine1.end.copy(p1);
          var intersection = new Vector3();
          intersection = localPlane.intersectLine(this.tempLine1, intersection);
          if (intersection === void 0) {
            console.error("Internal error: segment does not intersect plane.");
            output.segmentedObject1 = null;
            output.segmentedObject2 = null;
            return 0;
          }
          points1.push(intersection);
          points2.push(intersection.clone());
        }
      }
    }
    var newMass = object.userData.ammoPhysicsData.mass * 0.5;
    this.tempCM1.set(0, 0, 0);
    var radius1 = 0;
    var numPoints1 = points1.length;
    if (numPoints1 > 0) {
      for (var i = 0; i < numPoints1; i++)
        this.tempCM1.add(points1[i]);
      this.tempCM1.divideScalar(numPoints1);
      for (var i = 0; i < numPoints1; i++) {
        var p = points1[i];
        p.sub(this.tempCM1);
        radius1 = Math.max(radius1, p.x, p.y, p.z);
      }
      this.tempCM1.add(object.position);
    }
    this.tempCM2.set(0, 0, 0);
    var radius2 = 0;
    var numPoints2 = points2.length;
    if (numPoints2 > 0) {
      for (var i = 0; i < numPoints2; i++)
        this.tempCM2.add(points2[i]);
      this.tempCM2.divideScalar(numPoints2);
      for (var i = 0; i < numPoints2; i++) {
        var p = points2[i];
        p.sub(this.tempCM2);
        radius2 = Math.max(radius2, p.x, p.y, p.z);
      }
      this.tempCM2.add(object.position);
    }
    var object1 = null;
    var object2 = null;
    var numObjects = 0;
    if (numPoints1 > 4) {
      try {
        object1 = new Mesh(newConvexGeometry(points1), object.material);
        object1.position.copy(this.tempCM1);
        object1.quaternion.copy(object.quaternion);
        object1.userData = object.userData;
        this.prepareBreakableObject(object1, newMass, object.userData.ammoPhysicsData.velocity, object.userData.ammoPhysicsData.angularVelocity, 2 * radius1 > this.minSizeForBreak);
        numObjects++;
      } catch (error) {
        logger("Error in ConvexObjectBreaker.ts", true);
        logger(error, true);
      }
    }
    if (numPoints2 > 4) {
      try {
        object2 = new Mesh(newConvexGeometry(points2), object.material);
        object2.position.copy(this.tempCM2);
        object2.quaternion.copy(object.quaternion);
        object2.userData = object.userData;
        this.prepareBreakableObject(object2, newMass, object.userData.ammoPhysicsData.velocity, object.userData.ammoPhysicsData.angularVelocity, 2 * radius2 > this.minSizeForBreak);
        numObjects++;
      } catch (error) {
        logger("Error in ConvexObjectBreaker.ts", true);
        logger(error, true);
      }
    }
    output.object1 = object1;
    output.object2 = object2;
    return numObjects;
  }
};
ConvexObjectBreaker.transformFreeVector = function(v, m) {
  var x = v.x, y = v.y, z = v.z;
  var e = m.elements;
  v.x = e[0] * x + e[4] * y + e[8] * z;
  v.y = e[1] * x + e[5] * y + e[9] * z;
  v.z = e[2] * x + e[6] * y + e[10] * z;
  return v;
};
ConvexObjectBreaker.transformFreeVectorInverse = function(v, m) {
  var x = v.x, y = v.y, z = v.z;
  var e = m.elements;
  v.x = e[0] * x + e[1] * y + e[2] * z;
  v.y = e[4] * x + e[5] * y + e[6] * z;
  v.z = e[8] * x + e[9] * y + e[10] * z;
  return v;
};
ConvexObjectBreaker.transformTiedVectorInverse = function(v, m) {
  var x = v.x, y = v.y, z = v.z;
  var e = m.elements;
  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];
  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];
  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];
  return v;
};
ConvexObjectBreaker.transformPlaneToLocalSpace = function() {
  var v1 = new Vector3();
  return function transformPlaneToLocalSpace(plane, m, resultPlane) {
    resultPlane.normal.copy(plane.normal);
    resultPlane.constant = plane.constant;
    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1), m);
    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);
    resultPlane.constant = -referencePoint.dot(resultPlane.normal);
  };
}();

// node_modules/@enable3d/common/dist/wasmLoader.js
var wasmSupported = (() => {
  try {
    if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
      const module = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
      if (module instanceof WebAssembly.Module)
        return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
    }
  } catch (err) {
    if (err instanceof Error)
      console.error(err.message);
  }
  return false;
})();
var loadScriptAsync = (url, doneCallback) => {
  var tag = document.createElement("script");
  tag.onload = () => {
    doneCallback();
  };
  tag.onerror = () => {
    throw new Error(`failed to load ${url}`);
  };
  tag.async = true;
  tag.src = url;
  document.head.appendChild(tag);
};
var loadAmmoModule = (path, doneCallback) => {
  if (wasmSupported)
    loadScriptAsync(`${path}/ammo.wasm.js`, () => doneCallback());
  else
    loadScriptAsync(`${path}/ammo.js`, () => doneCallback());
};
var wasmLoader_default = loadAmmoModule;

// node_modules/@enable3d/common/dist/physicsLoader.js
var PhysicsLoader = (path, callback) => {
  if (typeof window !== "undefined")
    window.__loadPhysics = true;
  wasmLoader_default(path, () => {
    Ammo().then(() => {
      callback();
    });
  });
};

// node_modules/@enable3d/common/dist/types.js
var types_exports = {};

// node_modules/@enable3d/common/dist/applyMixins.js
function applyMixins(derivedCtor, constructors) {
  constructors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || /* @__PURE__ */ Object.create(null));
    });
  });
}
var applyMixins_default = applyMixins;

// node_modules/@enable3d/ammo-physics/dist/raycaster/closestRayResultCallback.js
var ClosestRayResultCallback = class {
  constructor(physics) {
    this.physics = physics;
  }
  getHitPointWorld() {
    const h = this._btRayCallback.get_m_hitPointWorld();
    const point = { x: h.x(), y: h.y(), z: h.z() };
    return point;
  }
  getHitNormalWorld() {
    const h = this._btRayCallback.get_m_hitNormalWorld();
    const normal = { x: h.x(), y: h.y(), z: h.z() };
    return normal;
  }
  getCollisionObject() {
    const rb = Ammo.castObject(this._btRayCallback.get_m_collisionObject(), Ammo.btRigidBody);
    return rb.threeObject;
  }
};

// node_modules/@enable3d/ammo-physics/dist/raycaster/allHitsRayResultCallback.js
var AllHitsRayResultCallback = class {
  constructor(physics) {
    this.physics = physics;
  }
  getHitPointsWorld() {
    const h = this._btRayCallback.get_m_hitPointWorld();
    const points = [];
    for (let i = h.size() - 1; i >= 0; i--) {
      const hh = h.at(i);
      points.push({ x: hh.x(), y: hh.y(), z: hh.z() });
    }
    return points;
  }
  // TODO: Remove this in future versions!
  getHitPointWorld() {
    logger("Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!");
    return this.getHitPointsWorld();
  }
  getHitNormalsWorld() {
    const h = this._btRayCallback.get_m_hitNormalWorld();
    const normals = [];
    for (let i = h.size() - 1; i >= 0; i--) {
      const hh = h.at(i);
      normals.push({ x: hh.x(), y: hh.y(), z: hh.z() });
    }
    return normals;
  }
  getCollisionObjects() {
    const threeObjects = [];
    const objects = this._btRayCallback.get_m_collisionObjects();
    for (let i = objects.size() - 1; i >= 0; i--) {
      const rb = Ammo.castObject(objects.at(i), Ammo.btRigidBody);
      threeObjects.push(rb.threeObject);
    }
    return threeObjects;
  }
};

// node_modules/@enable3d/ammo-physics/dist/raycaster/raycaster.js
var Raycaster = class {
  constructor(physics) {
    this.physics = physics;
  }
  setRayFromWorld(x = 0, y = 0, z = 0) {
    this._btRayFrom.setValue(x, y, z);
  }
  setRayToWorld(x = 0, y = 0, z = 0) {
    this._btRayTo.setValue(x, y, z);
  }
  hasHit() {
    return this._btRayCallback.hasHit();
  }
  rayTest() {
    if (typeof this._btRayCallback !== "undefined")
      Ammo.destroy(this._btRayCallback);
    this._btRayCallback = this.type === "closest" ? new Ammo.ClosestRayResultCallback(this._btRayFrom, this._btRayTo) : new Ammo.AllHitsRayResultCallback(this._btRayFrom, this._btRayTo);
    this.physics.physicsWorld.rayTest(this._btRayFrom, this._btRayTo, this._btRayCallback);
  }
  destroy() {
    if (typeof this._btRayFrom !== "undefined")
      Ammo.destroy(this._btRayFrom);
    if (typeof this._btRayTo !== "undefined")
      Ammo.destroy(this._btRayTo);
    if (typeof this._btRayCallback !== "undefined")
      Ammo.destroy(this._btRayCallback);
  }
};
var ClosestRaycaster = class {
  constructor(physics) {
    this.physics = physics;
    this.type = "closest";
    this._btRayFrom = new Ammo.btVector3(0, 0, 0);
    this._btRayTo = new Ammo.btVector3(0, 0, 0);
  }
};
var AllHitsRaycaster = class {
  constructor(physics) {
    this.physics = physics;
    this.type = "allHits";
    this._btRayFrom = new Ammo.btVector3(0, 0, 0);
    this._btRayTo = new Ammo.btVector3(0, 0, 0);
  }
};
applyMixins_default(ClosestRaycaster, [Raycaster, ClosestRayResultCallback]);
applyMixins_default(AllHitsRaycaster, [Raycaster, AllHitsRayResultCallback]);

// node_modules/@enable3d/ammo-physics/dist/lib/Clock.js
var Clock = class {
  constructor(autoStart = true) {
    this.autoStart = autoStart !== void 0 ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = (typeof performance === "undefined" ? Date : performance).now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = (typeof performance === "undefined" ? Date : performance).now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
};

// node_modules/@enable3d/ammo-physics/dist/physics.js
var AmmoPhysics = class extends import_events3.Events {
  constructor(scene, config = {}) {
    super();
    this.scene = scene;
    this.config = config;
    this.rigidBodies = [];
    this.earlierDetectedCollisions = [];
    this.complexShapes = ["plane", "hull", "hacd", "vhacd", "convexMesh", "concaveMesh"];
    this.gravity = config.gravity || { x: 0, y: -9.81, z: 0 };
    this.isHeadless = scene === "headless" ? true : false;
    this.tmpEuler = new Euler();
    this.tmpQuaternion = new Quaternion();
    this.tmpVector3 = new Vector3();
    this.tmpVector3a = new Vector3();
    this.tmpMatrix4 = new Matrix4();
    this.tmpMatrix4a = new Matrix4();
    this.tmpBtVector3 = new Ammo.btVector3();
    this.tmpBtQuaternion = new Ammo.btQuaternion(0, 0, 0, 1);
    this.emptyV3 = new Vector3();
    this.impactPoint = new Vector3();
    this.impactNormal = new Vector3();
    if (scene !== "headless") {
      this.defaultMaterial = new defaultMaterial_default();
    }
    this.start();
  }
  /** @deprecated Use worldTransform instead of tmpTrans. */
  get tmpTrans() {
    console.warn("Use worldTransform instead of tmpTrans.");
    return this.worldTransform;
  }
  /** @deprecated Use worldTransform instead of tmpTrans. */
  set tmpTrans(transform) {
    console.warn("Use worldTransform instead of tmpTrans.");
    this.worldTransform = transform;
  }
  /** Destroys a physics body. */
  destroy(body) {
    var _a;
    const b = Object.keys(body).includes("body") ? body.body : body;
    if (typeof (b == null ? void 0 : b.ammo) === "undefined")
      return;
    let obj = b.ammo.threeObject;
    const name = obj.name;
    if (name && obj) {
      if ((_a = obj == null ? void 0 : obj.body) == null ? void 0 : _a.ammo) {
        !obj.body.isSoftBody ? this.physicsWorld.removeRigidBody(obj.body.ammo) : this.physicsWorld.removeSoftBody(obj.body.ammo);
        obj.body.destructor();
        obj.body = void 0;
        obj.hasBody = false;
        delete b.ammo.threeObject;
        for (let i = 0; i < this.rigidBodies.length; i++) {
          if (this.rigidBodies[i].name === name) {
            this.rigidBodies.splice(i, 1);
            i--;
          }
        }
      }
    }
    if (this.scene === "headless" && obj)
      obj = null;
  }
  setup() {
    this.worldTransform = new Ammo.btTransform();
    if (typeof this.config.setupPhysicsWorld === "function")
      this.physicsWorld = this.config.setupPhysicsWorld();
    else
      this.physicsWorld = this.setupPhysicsWorld();
    if (this.scene !== "headless") {
      this.convexBreaker = new ConvexObjectBreaker();
      this.objectsToRemove = [];
      this.numObjectsToRemove = 0;
      for (let i = 0; i < 500; i++) {
        this.objectsToRemove[i] = null;
      }
    }
    this.collisionEvents = new CollisionEvents();
    this.factory = new Factories(this.scene);
    this.shapes = new shapes_default(this.factory, (object, config) => this.addExisting(object, config));
    this.constraints = new Constraints(this.worldTransform, this.physicsWorld);
    if (this.scene !== "headless")
      this.debugDrawer = new debugDrawer_default(this.scene, this.physicsWorld, {});
  }
  updateDebugger() {
    if (this.scene === "headless")
      return;
    if (this.debugDrawer && this.debugDrawer.enabled)
      this.debugDrawer.update();
  }
  setupPhysicsWorld() {
    const g = this.gravity;
    const { softBodies = false } = this.config;
    let physicsWorld;
    if (!softBodies) {
      const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration(), dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration), broadphase = new Ammo.btDbvtBroadphase(), solver = new Ammo.btSequentialImpulseConstraintSolver();
      physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
    }
    if (softBodies) {
      const collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration(), dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration), broadphase = new Ammo.btDbvtBroadphase(), solver = new Ammo.btSequentialImpulseConstraintSolver(), softBodySolver = new Ammo.btDefaultSoftBodySolver();
      physicsWorld = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
    }
    physicsWorld.setGravity(new Ammo.btVector3(g.x, g.y, g.z));
    return physicsWorld;
  }
  createDebrisFromBreakableObject(object, parent) {
    if (this.scene === "headless")
      return;
    object.material = parent.material;
    object.shape = "hull";
    object.fragmentDepth = parent.fragmentDepth + 1;
    object.name = `${parent.name}__DEBRIS_${object.id}`;
    this.scene.add(object);
    this.addExisting(object, { autoCenter: true });
    object.body.fractureImpulse = parent.body.fractureImpulse;
    object.body.breakable = false;
    setTimeout(() => {
      object.body.breakable = true;
    }, 2500);
  }
  removeDebris(object) {
    if (this.scene === "headless")
      return;
    this.scene.remove(object);
    this.destroy(object);
  }
  update(delta) {
    this.updatePhysics(delta);
    this.detectCollisions();
  }
  updatePhysics(delta) {
    const deltaTime = delta / 1e3;
    this.physicsWorld.stepSimulation(deltaTime, this.config.maxSubSteps || 4, this.config.fixedTimeStep || 1 / 60);
    for (let i = 0; i < this.rigidBodies.length; i++) {
      const objThree = this.rigidBodies[i];
      objThree.body.impact = [];
      const objPhys = objThree.body.ammo;
      const ms = objPhys.getMotionState();
      if (ms) {
        ms.getWorldTransform(this.worldTransform);
        if (objThree.body.didUpdate) {
          if (objThree.body._emitUpdateEvents)
            objThree.body.eventEmitter.emit("update");
          objThree.body.didUpdate = false;
        }
        if (objThree.body.ammo.isKinematicObject() && objThree.body.needUpdate) {
          objThree.getWorldQuaternion(this.tmpQuaternion);
          objThree.getWorldPosition(this.tmpVector3);
          this.tmpBtVector3.setValue(this.tmpVector3.x, this.tmpVector3.y, this.tmpVector3.z);
          this.tmpBtQuaternion.setValue(this.tmpQuaternion.x, this.tmpQuaternion.y, this.tmpQuaternion.z, this.tmpQuaternion.w);
          this.worldTransform.setOrigin(this.tmpBtVector3);
          this.worldTransform.setRotation(this.tmpBtQuaternion);
          ms.setWorldTransform(this.worldTransform);
          objThree.body.needUpdate = false;
        } else if (objThree.body.skipUpdate) {
        } else if (!objThree.body.ammo.isStaticObject()) {
          const p = this.worldTransform.getOrigin();
          const q = this.worldTransform.getRotation();
          const o = objThree.body.offset;
          if (objThree.body.ignoreScale) {
            this.tmpVector3a.set(objThree.scale.x, objThree.scale.y, objThree.scale.z);
          } else {
            const scale = objThree.body.ammo.getCollisionShape().getLocalScaling();
            this.tmpVector3a.set(scale.x(), scale.y(), scale.z());
          }
          this.tmpVector3.set(p.x() + o.x, p.y() + o.y, p.z() + o.z);
          this.tmpQuaternion.set(q.x(), q.y(), q.z(), q.w());
          this.tmpMatrix4.compose(this.tmpVector3, this.tmpQuaternion, this.tmpVector3a);
          if (objThree.parent) {
            if (parseInt(REVISION) >= 123)
              this.tmpMatrix4a.copy(objThree.parent.matrixWorld).invert();
            else
              this.tmpMatrix4a.getInverse(objThree.parent.matrixWorld);
          } else {
            this.tmpMatrix4a.identity();
          }
          this.tmpMatrix4a.multiply(this.tmpMatrix4);
          this.tmpMatrix4a.decompose(objThree.position, objThree.quaternion, objThree.scale);
        }
      }
    }
  }
  detectCollisions() {
    var _a, _b;
    const detectedCollisions = [];
    this.impactPoint.set(0, 0, 0);
    this.impactNormal.set(0, 0, 0);
    const dispatcher = this.physicsWorld.getDispatcher();
    const numManifolds = dispatcher.getNumManifolds();
    for (let i = 0; i < numManifolds; i++) {
      const contactManifold = dispatcher.getManifoldByIndexInternal(i);
      const numContacts = contactManifold.getNumContacts();
      const rb0 = Ammo.castObject(contactManifold.getBody0(), Ammo.btRigidBody);
      const rb1 = Ammo.castObject(contactManifold.getBody1(), Ammo.btRigidBody);
      const threeObject0 = rb0.threeObject;
      const threeObject1 = rb1.threeObject;
      if (!threeObject0 || !threeObject1) {
        continue;
      }
      if (rb0.name === "" && rb1.name === "")
        continue;
      const checkCollisions0 = (_a = threeObject0.body) == null ? void 0 : _a.checkCollisions;
      const checkCollisions1 = (_b = threeObject1.body) == null ? void 0 : _b.checkCollisions;
      const breakable0 = threeObject0.body.breakable;
      const breakable1 = threeObject1.body.breakable;
      const fractureImpulse0 = threeObject0.body.fractureImpulse;
      const fractureImpulse1 = threeObject1.body.fractureImpulse;
      const checkCollisions = checkCollisions0 || checkCollisions1;
      const checkBreakable = breakable0 || breakable1;
      if (typeof threeObject0.fragmentDepth === "undefined")
        threeObject0.fragmentDepth = 0;
      if (typeof threeObject1.fragmentDepth === "undefined")
        threeObject1.fragmentDepth = 0;
      if (!checkCollisions && !checkBreakable)
        continue;
      let contact = false;
      let maxImpulse = 0;
      let event = "start";
      for (let j = 0; j < numContacts; j++) {
        const contactPoint = contactManifold.getContactPoint(j);
        const distance = contactPoint.getDistance();
        if (distance <= 0) {
          contact = true;
          const impulse = contactPoint.getAppliedImpulse();
          const impactPoint = contactPoint.get_m_positionWorldOnB();
          const impactNormal = contactPoint.get_m_normalWorldOnB();
          if (checkCollisions0 || checkCollisions1) {
            const names = [threeObject0.uuid, threeObject1.uuid].sort();
            const combinedName = `${names[0]}__${names[1]}`;
            if (this.earlierDetectedCollisions.find((el) => el.combinedName === combinedName))
              event = "collision";
            if (!detectedCollisions.find((el) => el.combinedName === combinedName)) {
              detectedCollisions.push({ combinedName, collision: true });
              const point = { x: impactPoint.x(), y: impactPoint.y(), z: impactPoint.z() };
              const normal = { x: impactNormal.x(), y: impactNormal.y(), z: impactNormal.z() };
              threeObject0.body.impact.push({ impulse, point, normal, name: threeObject1.name });
              threeObject1.body.impact.push({ impulse, point, normal, name: threeObject0.name });
              this.collisionEvents.emit("collision", { bodies: [threeObject0, threeObject1], event });
            }
          }
          if (impulse >= maxImpulse) {
            maxImpulse = impulse;
            if (breakable0 || breakable1) {
              this.impactPoint.set(impactPoint.x(), impactPoint.y(), impactPoint.z());
              this.impactNormal.set(impactNormal.x(), impactNormal.y(), impactNormal.z());
            }
          }
          break;
        }
      }
      if (!contact)
        continue;
      if (!checkBreakable)
        continue;
      const MAX_FRAGMENT_DEPTH = 2;
      this.emptyV3.set(0, 0, 0);
      threeObject0.userData.ammoPhysicsData = {
        mass: 1,
        velocity: this.emptyV3,
        angularVelocity: this.emptyV3,
        breakable: breakable0,
        physicsBody: rb0
      };
      threeObject1.userData.ammoPhysicsData = {
        mass: 1,
        velocity: this.emptyV3,
        angularVelocity: this.emptyV3,
        breakable: breakable1,
        physicsBody: rb1
      };
      if (breakable0 && maxImpulse > fractureImpulse0 && threeObject0.fragmentDepth < MAX_FRAGMENT_DEPTH) {
        const debris = this.convexBreaker.subdivideByImpact(threeObject0, this.impactPoint, this.impactNormal, 1, 2);
        const numObjects = debris.length;
        for (let j = 0; j < numObjects; j++) {
          const vel = rb0.getLinearVelocity();
          const angVel = rb0.getAngularVelocity();
          const fragment = debris[j];
          fragment.userData.ammoPhysicsData.velocity.set(vel.x(), vel.y(), vel.z());
          fragment.userData.ammoPhysicsData.angularVelocity.set(angVel.x(), angVel.y(), angVel.z());
          this.createDebrisFromBreakableObject(fragment, threeObject0);
        }
        this.objectsToRemove[this.numObjectsToRemove++] = threeObject0;
      }
      if (breakable1 && maxImpulse > fractureImpulse1 && threeObject1.fragmentDepth < MAX_FRAGMENT_DEPTH) {
        const debris = this.convexBreaker.subdivideByImpact(threeObject1, this.impactPoint, this.impactNormal, 1, 2);
        const numObjects = debris.length;
        for (let j = 0; j < numObjects; j++) {
          const vel = rb1.getLinearVelocity();
          const angVel = rb1.getAngularVelocity();
          const fragment = debris[j];
          fragment.userData.ammoPhysicsData.velocity.set(vel.x(), vel.y(), vel.z());
          fragment.userData.ammoPhysicsData.angularVelocity.set(angVel.x(), angVel.y(), angVel.z());
          this.createDebrisFromBreakableObject(fragment, threeObject1);
        }
        this.objectsToRemove[this.numObjectsToRemove++] = threeObject1;
      }
    }
    for (let i = 0; i < this.numObjectsToRemove; i++) {
      this.removeDebris(this.objectsToRemove[i]);
    }
    this.numObjectsToRemove = 0;
    this.earlierDetectedCollisions.forEach((el) => {
      const { combinedName } = el;
      if (!detectedCollisions.find((el2) => el2.combinedName === combinedName)) {
        const split = combinedName.split("__");
        const obj0 = this.rigidBodies.find((obj) => obj.uuid === split[0]);
        const obj1 = this.rigidBodies.find((obj) => obj.uuid === split[1]);
        const event = "end";
        if (obj0 && obj1)
          this.collisionEvents.emit("collision", { bodies: [obj0, obj1], event });
      }
    });
    this.earlierDetectedCollisions = [...detectedCollisions];
  }
  setGravity(x = 0, y = -9.8, z = 0) {
    this.tmpBtVector3.setValue(x, y, z);
    this.physicsWorld.setGravity(this.tmpBtVector3);
  }
  get debug() {
    if (this.isHeadless)
      return null;
    return {
      enable: () => {
        this.debugDrawer.enable();
      },
      mode: (debugMode = 1) => {
        this.debugDrawer.setDebugMode(debugMode);
      },
      disable: () => {
        this.debugDrawer.disable();
      }
    };
  }
  start() {
    if (typeof Ammo === "undefined") {
      logger("Are you sure you included ammo.js?");
      return;
    }
    if (typeof Ammo === "function")
      Ammo().then(() => {
        this.setup();
      });
    else
      this.setup();
  }
  get add() {
    return {
      collider: (object1, object2, eventCallback) => this.collisionEvents.addCollider(object1, object2, eventCallback),
      constraints: this.constraints.addConstraints,
      existing: (object, config) => this.addExisting(object, config),
      plane: (planeConfig = {}, materialConfig = {}) => this.shapes.addPlane(planeConfig, materialConfig),
      sphere: (sphereConfig = {}, materialConfig = {}) => this.shapes.addSphere(sphereConfig, materialConfig),
      ground: (groundConfig = {}, materialConfig = {}) => this.shapes.addGround(groundConfig, materialConfig),
      box: (boxConfig = {}, materialConfig = {}) => this.shapes.addBox(boxConfig, materialConfig),
      capsule: (capsuleConfig = {}, materialConfig = {}) => this.shapes.addCapsule(capsuleConfig, materialConfig),
      cylinder: (cylinderConfig = {}, materialConfig = {}) => this.shapes.addCylinder(cylinderConfig, materialConfig),
      cone: (coneConfig = {}, materialConfig = {}) => this.shapes.addCone(coneConfig, materialConfig),
      torus: (torusConfig = {}, materialConfig = {}) => this.shapes.addTorus(torusConfig, materialConfig),
      extrude: (extrudeConfig, materialConfig = {}) => this.shapes.addExtrude(extrudeConfig, materialConfig),
      /**
       * Creates a new Raycaster
       * @param type Returns only the closes body by default. Can be 'closest' or 'allHits'.
       */
      raycaster: (type = "closest") => {
        if (type === "closest")
          return new ClosestRaycaster(this);
        else
          return new AllHitsRaycaster(this);
      }
    };
  }
  prepareThreeObjectForCollisionShape(object, config = {}) {
    var _a, _b;
    const { autoCenter = false } = config;
    const defaultParams = {
      width: 1,
      height: 1,
      depth: 1,
      radius: 1,
      radiusTop: 1,
      radiusBottom: 1,
      tube: 0.4,
      tubularSegments: 6
      // for the torus
    };
    let shape = "unknown";
    const type = ((_a = object.geometry) == null ? void 0 : _a.type) || "unknown";
    if (/box/i.test(type))
      shape = "box";
    else if (/cone/i.test(type))
      shape = "cone";
    else if (/cylinder/i.test(type))
      shape = "cylinder";
    else if (/extrude/i.test(type))
      shape = "extrude";
    else if (/plane/i.test(type))
      shape = "plane";
    else if (/sphere/i.test(type))
      shape = "sphere";
    else if (/torus/i.test(type))
      shape = "torus";
    let params = { ...defaultParams, ...(_b = object == null ? void 0 : object.geometry) == null ? void 0 : _b.parameters };
    if (config.shape) {
      params = { ...defaultParams, ...config };
      shape = config.shape;
    } else if (object.shape) {
      shape = object.shape;
    }
    ;
    Object.keys(params).forEach((key) => {
      if (typeof params[key] === "undefined" && defaultParams[key]) {
        params[key] = defaultParams[key];
      }
    });
    if (autoCenter) {
      if (object.isMesh && object.geometry) {
        object.geometry.center();
      } else if (object.isGroup) {
        const box = new Box3();
        const center = new Vector3();
        box.setFromObject(object).getCenter(center);
        object.traverse((child) => {
          if (child.isMesh) {
            child.geometry.translate(-center.x, -center.y, -center.z);
          }
        });
      }
    }
    if (shape === "cylinder")
      params.radius = config.radius || params.radiusTop;
    if (shape === "extrude")
      shape = "hacd";
    if (shape === "mesh" || shape === "convex")
      shape = "convexMesh";
    if (shape === "concave")
      shape = "concaveMesh";
    if (shape === "unknown") {
      logger(`Shape for ${object == null ? void 0 : object.name} not recognized! Will fallback to box.`);
      shape = "box";
    }
    return { shape, params, object };
  }
  createCollisionShape(shape, params, object) {
    const quat = (object == null ? void 0 : object.quaternion) ? object == null ? void 0 : object.quaternion : new Quaternion(0, 0, 0, 1);
    const { axis = "y" } = params;
    const btHalfExtents = new Ammo.btVector3();
    const geometry = object == null ? void 0 : object.geometry;
    if (object && (geometry == null ? void 0 : geometry.isGeometry)) {
      object.geometry = new BufferGeometry().fromGeometry(geometry);
    }
    const extractData = (object2) => {
      const matrixWorld = new Matrix4().elements;
      const vertices = [];
      const matrices = [];
      const indexes = [];
      iterateGeometries(object2, {}, (vertexArray, matrixArray, indexArray) => {
        vertices.push(vertexArray);
        matrices.push(matrixArray);
        indexes.push(indexArray);
      });
      return { vertices, matrices, indexes, matrixWorld };
    };
    let d = {};
    if (this.complexShapes.indexOf(shape) !== -1)
      d = extractData(object);
    let collisionShape;
    switch (shape) {
      case "box":
        btHalfExtents.setValue(params.width / 2, params.height / 2, params.depth / 2);
        collisionShape = new Ammo.btBoxShape(btHalfExtents);
        break;
      case "sphere":
        collisionShape = new Ammo.btSphereShape(params.radius);
        break;
      case "cylinder":
        switch (axis) {
          case "y":
            btHalfExtents.setValue(params.radius, params.height / 2, params.radius);
            collisionShape = new Ammo.btCylinderShape(btHalfExtents);
            break;
          case "x":
            btHalfExtents.setValue(params.height / 2, params.radius, params.radius);
            collisionShape = new Ammo.btCylinderShapeX(btHalfExtents);
            break;
          case "z":
            btHalfExtents.setValue(params.radius, params.radius, params.height / 2);
            collisionShape = new Ammo.btCylinderShapeZ(btHalfExtents);
            break;
        }
        break;
      case "cone":
        switch (axis) {
          case "y":
            collisionShape = new Ammo.btConeShape(params.radius, params.height);
            break;
          case "x":
            collisionShape = new Ammo.btConeShapeX(params.radius, params.height);
            break;
          case "z":
            collisionShape = new Ammo.btConeShapeZ(params.radius, params.height);
            break;
        }
        break;
      case "capsule":
        switch (axis) {
          case "y":
            collisionShape = new Ammo.btCapsuleShape(params.radius, params.height);
            break;
          case "x":
            collisionShape = new Ammo.btCapsuleShapeX(params.radius, params.height);
            break;
          case "z":
            collisionShape = new Ammo.btCapsuleShapeZ(params.radius, params.height);
            break;
        }
        break;
      case "torus":
        collisionShape = createTorusShape(params, quat);
        break;
      case "plane":
        collisionShape = createTriMeshShape(d.vertices, d.matrices, d.indexes, d.matrixWorld, {
          ...params,
          concave: false
        });
        break;
      case "hull":
        collisionShape = createHullShape(d.vertices, d.matrices, d.matrixWorld, params);
        break;
      case "hacd":
        collisionShape = createHACDShapes(d.vertices, d.matrices, d.indexes, d.matrixWorld, params);
        break;
      case "vhacd":
        collisionShape = createVHACDShapes(d.vertices, d.matrices, d.indexes, d.matrixWorld, params);
        break;
      case "convexMesh":
        collisionShape = createTriMeshShape(d.vertices, d.matrices, d.indexes, d.matrixWorld, {
          ...params,
          concave: false
        });
        break;
      case "concaveMesh":
        collisionShape = createTriMeshShape(d.vertices, d.matrices, d.indexes, d.matrixWorld, {
          ...params,
          concave: true
        });
        break;
    }
    Ammo.destroy(btHalfExtents);
    const { x, y, z } = params;
    if (x || y || z) {
      collisionShape._compoundOffset = { x: x || 0, y: y || 0, z: z || 0 };
    }
    if (Array.isArray(collisionShape))
      collisionShape = this.mergeCollisionShapesToCompoundShape(collisionShape);
    return collisionShape;
  }
  mergeCollisionShapesToCompoundShape(collisionShapes) {
    const compoundShape = new Ammo.btCompoundShape();
    collisionShapes.forEach((shape) => {
      const { _childOffset, _compoundOffset } = shape;
      if (_childOffset) {
        const { pos, quat, scale, margin } = _childOffset;
        const transform = this.applyPosQuatScaleMargin(shape, pos, quat, scale, margin);
        compoundShape.addChildShape(transform, shape);
      } else if (_compoundOffset) {
        const transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(_compoundOffset.x, _compoundOffset.y, _compoundOffset.z));
        compoundShape.addChildShape(transform, shape);
      } else {
        const transform = new Ammo.btTransform();
        transform.setIdentity();
        compoundShape.addChildShape(transform, shape);
      }
    });
    return compoundShape;
  }
  addExisting(object, config = {}) {
    const { hasBody } = object;
    if (hasBody) {
      logger(`Object "${object.name}" already has a physical body!`);
      return;
    }
    const pos = new Vector3();
    const quat = new Quaternion();
    const scale = new Vector3();
    object.getWorldPosition(pos);
    object.getWorldQuaternion(quat);
    object.getWorldScale(scale);
    const isStaticObject = (config.collisionFlags || 0).toString(2).slice(-1) === "1";
    const isKinematicObject = (config.collisionFlags || 0).toString(2).slice(-2, -1) === "1";
    const {
      shape = "unknown",
      compound = [],
      mass = isStaticObject || isKinematicObject ? 0 : 1,
      // set default mass of 0 for static objects, and 1 for all other objects
      collisionFlags = 0,
      collisionGroup = 1,
      collisionMask = -1,
      offset = void 0,
      breakable = false,
      addChildren = true,
      margin = 0.01,
      ignoreScale = false,
      fractureImpulse = 1
    } = config;
    if (ignoreScale)
      scale.set(1, 1, 1);
    if (compound.length >= 1) {
      const collisionShapes2 = compound.map((s) => this.createCollisionShape(s.shape, s));
      const compoundShape = this.mergeCollisionShapesToCompoundShape(collisionShapes2);
      const localTransform2 = this.applyPosQuatScaleMargin(compoundShape, pos, quat, scale, margin);
      const rigidBody2 = this.collisionShapeToRigidBody(compoundShape, localTransform2, mass, isKinematicObject);
      this.addRigidBodyToWorld(object, rigidBody2, collisionFlags, collisionGroup, collisionMask, offset);
      object.body.breakable = breakable;
      object.body.fractureImpulse = fractureImpulse;
      object.body.ignoreScale = ignoreScale;
      return;
    }
    const collisionShapes = [];
    if (shape !== "unknown" || object.isMesh) {
      const p = this.prepareThreeObjectForCollisionShape(object, config);
      const cs = this.createCollisionShape(p.shape, p.params, p.object);
      collisionShapes.push(cs);
    }
    if (shape === "unknown" && addChildren && object.children.length >= 1) {
      object.children.forEach((child) => {
        if (child.isMesh) {
          const p = this.prepareThreeObjectForCollisionShape(child);
          const cs = this.createCollisionShape(p.shape, p.params, p.object);
          cs._childOffset = {
            pos: child.position.clone(),
            quat: child.quaternion.clone(),
            scale: child.scale.clone(),
            margin
          };
          collisionShapes.push(cs);
        }
      });
    }
    if (collisionShapes.length === 0) {
      const p = this.prepareThreeObjectForCollisionShape(object, config);
      const cs = this.createCollisionShape(p.shape, p.params, p.object);
      collisionShapes.push(cs);
    }
    const collisionShape = collisionShapes.length === 1 ? collisionShapes[0] : this.mergeCollisionShapesToCompoundShape(collisionShapes);
    const localTransform = this.applyPosQuatScaleMargin(collisionShape, pos, quat, scale, margin);
    const rigidBody = this.collisionShapeToRigidBody(collisionShape, localTransform, mass, isKinematicObject);
    this.addRigidBodyToWorld(object, rigidBody, collisionFlags, collisionGroup, collisionMask, offset);
    object.body.breakable = breakable;
    object.body.fractureImpulse = fractureImpulse;
    object.body.ignoreScale = ignoreScale;
  }
  addRigidBodyToWorld(object, rigidBody, collisionFlags, collisionGroup, collisionMask, offset) {
    this.rigidBodies.push(object);
    this.physicsWorld.addRigidBody(rigidBody, collisionGroup, collisionMask);
    const ptr = Object.values(rigidBody)[0];
    if (!object.name)
      object.name = `object-${object.id}`;
    rigidBody.name = object.name;
    object.body = new physicsBody_default(this, rigidBody);
    object.hasBody = true;
    object.ptr = ptr;
    rigidBody.threeObject = object;
    if (offset)
      object.body.offset = { x: 0, y: 0, z: 0, ...offset };
    object.body.setCollisionFlags(collisionFlags);
  }
  applyPosQuatScaleMargin(collisionShape, pos = new Vector3(), quat = new Quaternion(), scale = new Vector3(), margin = 0.01) {
    collisionShape.setMargin(margin);
    const rotation = new Ammo.btQuaternion(0, 0, 0, 1);
    rotation.setValue(quat.x, quat.y, quat.z, quat.w);
    const localTransform = new Ammo.btTransform();
    localTransform.setIdentity();
    localTransform.getOrigin().setValue(pos.x, pos.y, pos.z);
    localTransform.setRotation(rotation);
    Ammo.destroy(rotation);
    const localScale = new Ammo.btVector3(scale.x, scale.y, scale.z);
    collisionShape.setLocalScaling(localScale);
    Ammo.destroy(localScale);
    return localTransform;
  }
  collisionShapeToRigidBody(collisionShape, localTransform, mass, disableDeactivation) {
    const motionState = new Ammo.btDefaultMotionState(localTransform);
    const localInertia = new Ammo.btVector3(0, 0, 0);
    if (mass > 0)
      collisionShape.calculateLocalInertia(mass, localInertia);
    const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, collisionShape, localInertia);
    const rigidBody = new Ammo.btRigidBody(rbInfo);
    if (mass > 0 || disableDeactivation)
      rigidBody.setActivationState(4);
    return rigidBody;
  }
};
export {
  AllHitsRaycaster,
  AmmoPhysics,
  Clock,
  ClosestRaycaster,
  ExtendedGroup,
  ExtendedMesh,
  ExtendedObject3D,
  PhysicsLoader,
  types_exports as Types
};
/*! Bundled license information:

@yandeu/events/cjs/index.js:
  (**
   * @package      npmjs.com/package/@yandeu/events (events.min.js)
   *
   * @author       Arnout Kazemier (https://github.com/3rd-Eden)
   * @copyright    Copyright (c) 2014 Arnout Kazemier
   * @license      {@link https://github.com/primus/eventemitter3/blob/master/LICENSE|MIT}
   *
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/yandeu/events
   * @license      {@link https://github.com/yandeu/events/blob/master/LICENSE|MIT}
   *)

@enable3d/common/dist/physicsBody.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/common/dist/extendedObject3D.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/common/dist/extendedMesh.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/common/dist/extendedGroup.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/ammo-physics/dist/shapes.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/ammo-physics/dist/constraints.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/ammo-physics/dist/three-to-ammo.js:
  (**
   * @author       Kevin Lee (https://github.com/InfiniteLee)
   * @copyright    Copyright (c) 2020 Kevin Lee; Project Url: https://github.com/InfiniteLee/three-to-ammo
   * @license      {@link https://github.com/InfiniteLee/three-to-ammo/blob/master/LICENSE|MPL-2.0}
   *)

@enable3d/ammo-physics/dist/torusShape.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/common/dist/factories.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/ammo-physics/dist/collisionEvents.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/ammo-physics/dist/debugDrawer.js:
  (**
   * @author       Kevin Lee (https://github.com/InfiniteLee)
   * @copyright    Copyright (c) 2019 Kevin Lee; Project Url: https://github.com/InfiniteLee/ammo-debug-drawer
   * @license      {@link https://github.com/InfiniteLee/ammo-debug-drawer/blob/master/LICENSE|MPL-2.0}
   *)

@enable3d/common/dist/types.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/ammo-physics/dist/raycaster/closestRayResultCallback.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/ammo-physics/dist/raycaster/allHitsRayResultCallback.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/ammo-physics/dist/raycaster/raycaster.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)

@enable3d/ammo-physics/dist/physics.js:
  (**
   * @author       Yannick Deubel (https://github.com/yandeu)
   * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
   * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
   *)
*/
//# sourceMappingURL=@enable3d_ammo-physics.js.map
